2019-04-12 12:13:54,442 INFO main - command line arguments: [-jvm4testexecution  /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin  -mode  jgenprog  -scope  global  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -location  defect4j_tests/math_86/  -dependencies  ./examples/libs/junit-4.4.jar  -flthreshold  0.5  -maxtime  100  -stopfirst  true]
2019-04-12 12:13:57,879 INFO main - -Executing Gzoltar classpath: /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//bin//default from 194 classes with test cases
2019-04-12 12:13:57,879 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar fault localization: min susp value parameter: 0.5
2019-04-12 12:13:59,871 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - -gz-Adding classpath: [/home/jan_gerling/astor/./examples/libs/junit-4.4.jar, /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//bin//default]
2019-04-12 12:14:22,241 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274
2019-04-12 12:14:22,241 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite
2019-04-12 12:14:22,272 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar Test Result Total:1894, fails: 2, GZoltar suspicious 15671
2019-04-12 12:14:22,427 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar found: 1000 with susp > 0.5, we consider: 1000
2019-04-12 12:14:22,459 INFO main - building model: /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//src//default, compliance level: 8
2019-04-12 12:14:40,150 INFO main - 
---- Initial suspicious size: 994
2019-04-12 12:14:43,174 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 12:14:44,534 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 12:14:44,778 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 12:14:45,122 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 12:14:45,262 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:14:45,267 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:14:45,290 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:45,294 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 12:14:45,340 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:45,342 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 12:14:45,423 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 12:14:45,481 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 12:14:45,493 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:14:45,503 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:45,505 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 12:14:45,509 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:14:45,524 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:45,525 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:14:45,527 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 12:14:45,546 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 12:14:45,605 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 12:14:45,628 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 12:14:45,635 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:45,638 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 12:14:45,712 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 12:14:45,727 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 12:14:45,735 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 12:14:45,772 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 12:14:45,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:45,794 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:45,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:45,794 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:45,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:14:45,794 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:14:45,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 12:14:45,794 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 12:14:45,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 12:14:45,795 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 12:14:45,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 12:14:45,796 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 12:14:45,796 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 12:14:45,797 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:14:45,797 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 12:14:45,798 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 12:14:45,798 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 12:14:45,799 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 12:14:45,799 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 12:14:45,799 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 12:14:45,799 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 12:14:45,799 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 12:14:45,799 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 12:14:45,799 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 12:14:45,799 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 12:14:45,799 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 12:14:45,799 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 12:14:45,815 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:45,817 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:45,848 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:14:46,017 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 12:14:46,051 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:14:46,051 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:14:46,051 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 12:14:46,051 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 12:14:46,051 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 12:14:46,051 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 12:14:46,051 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 12:14:46,051 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 12:14:46,145 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 12:14:46,146 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 12:14:46,175 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 12:14:46,221 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 12:14:46,295 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 12:14:46,402 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 12:14:46,456 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:14:46,518 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 12:14:46,520 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 12:14:46,662 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:46,710 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:46,778 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:47,638 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 12:14:47,640 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 12:14:47,675 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 12:14:47,677 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 12:14:47,738 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 12:14:47,740 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 12:14:47,743 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 12:14:47,759 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 12:14:47,764 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 12:14:47,788 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 12:14:47,854 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:47,906 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:47,930 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 12:14:47,935 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 12:14:47,973 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 12:14:47,977 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 12:14:48,028 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 12:14:48,044 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 12:14:48,045 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 12:14:48,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 12:14:48,474 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 12:14:48,493 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 12:14:48,539 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 12:14:48,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:48,542 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:48,762 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 12:14:48,770 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 12:14:48,792 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 12:14:48,884 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 12:14:49,007 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 12:14:49,027 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 12:14:49,031 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 12:14:49,046 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 12:14:49,092 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 12:14:49,102 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 12:14:49,247 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 12:14:49,291 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 12:14:49,298 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 12:14:49,305 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 12:14:49,334 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 12:14:49,576 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 12:14:49,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 12:14:49,719 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 12:14:49,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 12:14:49,844 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 12:14:49,972 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 12:14:49,994 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 12:14:50,061 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 12:14:50,065 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 12:14:50,177 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 12:14:50,183 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:50,183 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:50,183 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:50,183 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:50,183 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 12:14:50,185 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 12:14:50,188 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:50,189 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:50,195 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 12:14:50,195 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 12:14:50,195 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:50,195 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:50,214 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 12:14:50,236 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 12:14:50,263 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 12:14:50,284 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 12:14:50,309 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 12:14:50,352 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 12:14:50,376 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 12:14:50,382 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 12:14:50,404 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 12:14:50,407 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 12:14:50,489 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 12:14:50,579 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 12:14:50,602 INFO main - Total suspicious from FL: 994,  811
2019-04-12 12:14:50,603 INFO main - Total ModPoint created: 811
2019-04-12 12:14:50,603 INFO main - Creating program variant #1, [Variant id: 1, #gens: 811, #ops: 0, parent:-]
2019-04-12 12:14:51,958 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 12:14:52,790 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 12:14:52,922 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 12:14:53,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 12:14:53,226 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:14:53,230 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:14:53,250 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:53,253 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 12:14:53,293 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:53,309 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 12:14:53,352 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 12:14:53,409 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 12:14:53,413 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:14:53,418 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:53,421 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 12:14:53,425 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:14:53,426 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:53,428 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:14:53,432 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 12:14:53,460 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 12:14:53,491 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 12:14:53,510 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 12:14:53,515 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:53,518 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 12:14:53,552 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 12:14:53,558 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 12:14:53,566 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 12:14:53,579 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 12:14:53,589 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 12:14:53,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 12:14:53,591 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 12:14:53,591 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 12:14:53,591 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:53,591 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:14:53,591 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 12:14:53,591 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 12:14:53,591 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 12:14:53,591 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 12:14:53,591 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:53,591 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:14:53,591 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 12:14:53,598 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 12:14:53,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 12:14:53,599 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 12:14:53,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 12:14:53,599 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 12:14:53,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 12:14:53,599 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 12:14:53,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 12:14:53,599 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 12:14:53,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 12:14:53,599 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:14:53,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:14:53,599 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 12:14:53,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 12:14:53,599 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:53,600 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:53,600 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:53,600 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:53,600 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 12:14:53,600 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 12:14:53,600 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:53,600 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:53,601 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:53,601 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:53,608 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:14:53,609 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:14:53,609 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 12:14:53,609 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 12:14:53,609 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:14:53,610 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:14:53,610 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 12:14:53,610 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 12:14:53,610 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 12:14:53,610 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 12:14:53,610 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 12:14:53,610 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 12:14:53,610 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 12:14:53,610 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 12:14:53,610 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 12:14:53,610 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 12:14:53,610 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 12:14:53,610 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 12:14:53,610 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 12:14:53,611 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 12:14:53,611 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 12:14:53,618 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:14:53,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:53,648 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:14:53,836 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 12:14:53,865 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:14:53,866 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:14:53,866 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 12:14:53,866 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 12:14:53,866 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 12:14:53,866 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 12:14:53,866 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 12:14:53,866 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 12:14:53,954 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 12:14:53,956 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 12:14:53,983 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 12:14:54,074 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 12:14:54,193 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 12:14:54,309 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 12:14:54,350 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:14:54,420 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 12:14:54,423 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 12:14:54,508 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:54,564 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:54,614 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:55,636 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 12:14:55,638 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 12:14:55,692 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 12:14:55,693 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 12:14:55,724 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 12:14:55,725 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 12:14:55,727 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 12:14:55,743 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 12:14:55,749 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 12:14:55,780 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 12:14:55,830 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:55,862 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:14:55,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 12:14:55,893 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 12:14:55,916 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 12:14:55,920 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 12:14:55,975 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 12:14:55,984 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 12:14:55,984 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 12:14:56,330 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 12:14:56,335 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 12:14:56,388 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 12:14:56,389 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:56,390 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:14:56,546 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 12:14:56,551 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 12:14:56,560 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 12:14:56,594 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 12:14:56,668 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 12:14:56,674 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 12:14:56,689 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 12:14:56,692 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 12:14:56,722 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 12:14:56,742 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 12:14:56,839 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 12:14:56,859 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 12:14:56,865 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 12:14:56,871 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 12:14:56,899 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 12:14:57,094 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 12:14:57,206 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 12:14:57,227 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 12:14:57,277 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 12:14:57,317 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 12:14:57,405 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 12:14:57,414 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 12:14:57,441 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 12:14:57,444 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 12:14:57,535 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 12:14:57,540 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:57,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:14:57,540 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:57,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:14:57,540 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 12:14:57,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 12:14:57,540 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:57,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:14:57,540 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 12:14:57,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 12:14:57,540 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:57,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:14:57,580 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 12:14:57,589 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 12:14:57,617 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 12:14:57,636 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 12:14:57,656 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 12:14:57,687 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 12:14:57,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 12:14:57,712 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 12:14:57,728 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 12:14:57,732 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 12:14:57,814 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 12:14:57,866 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 12:14:57,873 INFO main - Total suspicious from FL: 994,  811
2019-04-12 12:14:57,873 INFO main - Total ModPoint created: 811
2019-04-12 12:14:57,873 INFO main - Creating program variant #2, [Variant id: 2, #gens: 811, #ops: 0, parent:-]
2019-04-12 12:14:58,837 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 12:14:59,532 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 12:14:59,739 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 12:14:59,920 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 12:15:00,028 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:15:00,031 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:15:00,035 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:15:00,037 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 12:15:00,047 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:15:00,049 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 12:15:00,073 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 12:15:00,110 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 12:15:00,114 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:15:00,118 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:15:00,120 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 12:15:00,122 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:15:00,123 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:15:00,124 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:15:00,125 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 12:15:00,136 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 12:15:00,152 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 12:15:00,156 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 12:15:00,160 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:15:00,161 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 12:15:00,202 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 12:15:00,205 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 12:15:00,216 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 12:15:00,226 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 12:15:00,233 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 12:15:00,233 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 12:15:00,234 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 12:15:00,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 12:15:00,235 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 12:15:00,235 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 12:15:00,238 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 12:15:00,240 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:15:00,271 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 12:15:00,360 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 12:15:00,372 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:15:00,372 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:15:00,372 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 12:15:00,372 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 12:15:00,372 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 12:15:00,372 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 12:15:00,372 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 12:15:00,372 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 12:15:00,406 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 12:15:00,408 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 12:15:00,421 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 12:15:00,438 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 12:15:00,474 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 12:15:00,574 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 12:15:00,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 12:15:00,663 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 12:15:00,666 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 12:15:00,759 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:15:00,790 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:15:00,834 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:15:01,427 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 12:15:01,428 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 12:15:01,459 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 12:15:01,461 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 12:15:01,508 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 12:15:01,510 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 12:15:01,512 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 12:15:01,516 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 12:15:01,519 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 12:15:01,543 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 12:15:01,591 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:15:01,633 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 12:15:01,677 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 12:15:01,682 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 12:15:01,706 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 12:15:01,709 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 12:15:01,766 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 12:15:01,770 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 12:15:01,770 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 12:15:01,770 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 12:15:01,770 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 12:15:01,770 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 12:15:01,770 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 12:15:01,770 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 12:15:01,770 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 12:15:01,770 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 12:15:01,770 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 12:15:01,770 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 12:15:01,770 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 12:15:01,771 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 12:15:01,771 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 12:15:01,771 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 12:15:01,771 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 12:15:01,771 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 12:15:01,771 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 12:15:01,771 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 12:15:02,173 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 12:15:02,192 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 12:15:02,239 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 12:15:02,240 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:15:02,241 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 12:15:02,418 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 12:15:02,437 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 12:15:02,446 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 12:15:02,525 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 12:15:02,590 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 12:15:02,597 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 12:15:02,600 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 12:15:02,603 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 12:15:02,621 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 12:15:02,630 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 12:15:02,729 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 12:15:02,784 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 12:15:02,791 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 12:15:02,810 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 12:15:02,858 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 12:15:03,220 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 12:15:03,356 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 12:15:03,374 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 12:15:03,437 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 12:15:03,471 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 12:15:03,552 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 12:15:03,572 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 12:15:03,640 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 12:15:03,643 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 12:15:03,795 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 12:15:03,817 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:15:03,817 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 12:15:03,817 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:15:03,817 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 12:15:03,817 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 12:15:03,817 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 12:15:03,817 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:15:03,817 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 12:15:03,817 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 12:15:03,817 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 12:15:03,817 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:15:03,817 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 12:15:03,860 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 12:15:03,880 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 12:15:03,940 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 12:15:03,946 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 12:15:03,983 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 12:15:04,036 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 12:15:04,045 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 12:15:04,062 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 12:15:04,066 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 12:15:04,068 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 12:15:04,136 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 12:15:04,174 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 12:15:04,188 INFO main - Total suspicious from FL: 994,  811
2019-04-12 12:15:04,188 INFO main - Total ModPoint created: 811
2019-04-12 12:15:04,188 INFO main - Creating program variant #3, [Variant id: 3, #gens: 811, #ops: 0, parent:-]
2019-04-12 12:19:03,476 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - ---Configuration properties:---Execution values
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:faultlocalization= fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:packageToInstrument= 
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:flthreshold= 0.5
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:numberExecutions= 1
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuiteresultfolder= evosuite
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoredTestCases= 
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:skipfaultlocalization= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxGeneration= 200
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxsuspcandidates= 1000
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax2= 960000
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax1= 120000
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:workingDirectory= /home/jan_gerling/astor/./outputMutation
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mode= jgenprog
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoreflakyinfl= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:uniqueoptogen= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pathToMVNRepository= 
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:timezone= America/Los_Angeles
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:applyCrossover= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clonegranularity= types
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:modificationpointnavigation= weight
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clusteringfilename= clustering.csv
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxtime= 100
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:probagenmutation= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:alternativecompliancelevel= 4
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:version-location= ./math-version/
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:location= defect4j_tests/math_86/
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:filterfaultlocalization= true
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:stopfirst= true
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4testexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bugId= 280
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mutationrate= 1 
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:forceExecuteRegression= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:projectIdentifier= 
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_buggy_class= true
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoRunOnBuggyClass= true
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resetoperations= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4evosuitetestexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:seed= 0
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:testbystep= false
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srctestfolder= /src/test/
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:javacompliancelevel= 8
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bintestfolder= /target/test-classes/
2019-04-12 12:19:03,477 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:fitnessfunction= fr.inria.astor.core.loop.population.TestCaseFitnessFunction
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:commandTrunk= 50000
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:dependenciespath= ./examples/libs/junit-4.4.jar
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:multipointmodification= false
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:transformingredient= false
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:validation= process
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:scope= global
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitetimeout= 120
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoDSE= false
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:elementsToMutate= 10
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:allpoints= false
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resourcesfolder= /src/main/resources:/src/test/resources:
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:regressionforfaultlocalization= true
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:population= 3
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:saveall= false
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pvariantfoldername= variant-
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:populationcontroller= fr.inria.astor.core.loop.population.TestCaseBasedFitnessPopulationController
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:savesolution= true
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srcjavafolder= /src/java/
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_affected_by_op= true
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:binjavafolder= /target/classes/
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:reintroduce= original-parents
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:learningdir= 
2019-04-12 12:19:03,478 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 12:19:03,478 INFO main - 
----Starting Solution Search
2019-04-12 12:19:35,229 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:19:35,229 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:19:35,250 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:19:40,534 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:19:40,534 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null) {
			cachedL = getLT().transpose();
		}
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 12:19:40,536 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 12:19:53,402 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:19:53,403 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:19:53,419 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:24:14,408 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:24:14,408 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 12:24:14,410 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null)
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 12:25:13,129 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:25:13,129 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:25:13,174 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:29:51,481 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:29:51,483 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:29:51,489 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:32:06,858 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:32:06,858 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:32:06,876 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:35:04,151 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:35:04,151 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:35:04,157 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 12:35:09,913 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:35:09,914 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:35:09,932 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:38:40,559 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:38:40,575 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:38:40,605 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:43:58,880 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:43:58,881 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:43:58,920 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:47:18,195 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:47:18,195 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:47:18,970 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:49:10,036 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:49:10,036 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:49:10,055 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:50:05,756 INFO main - Time Repair Loop (s): 1862.278
2019-04-12 12:50:05,757 INFO main - 
----SUMMARY_EXECUTION---
2019-04-12 12:50:05,757 INFO main - 
successful_ing_attempts (0): []
2019-04-12 12:50:05,757 INFO main - 
failing_ing_attempts (600): [11, 68, 2, 6, 0, 0, 18, 19, 6, 0, 5, 12, 0, 19, 3, 0, 2, 3, 1, 0, 0, 6, 8, 3, 0, 6, 0, 0, 2, 10, 808, 4, 0, 21, 2, 0, 33, 2, 4, 35, 4, 2, 0, 3, 1, 10, 5, 0, 5, 3, 1, 84, 2, 0, 0, 0, 15, 67, 4, 7, 7, 0, 0, 16, 3, 0, 18, 0, 0, 34, 9, 1, 5, 4, 3, 347, 1, 0, 4, 6, 39, 5, 2, 7, 56, 11, 0, 1, 4, 0, 96, 0, 0, 799, 0, 19, 0, 0, 4, 2, 10, 0, 0, 4, 0, 26, 2, 2, 0, 1, 6, 0, 15, 1, 0, 0, 2, 2, 2, 1, 0, 11, 342, 0, 0, 4, 2, 1, 5, 0, 0, 109, 9, 2, 0, 95, 803, 10, 1, 0, 315, 0, 802, 59, 9, 8, 25, 6, 0, 18, 13, 71, 4, 15, 0, 12, 0, 5, 2, 1, 37, 2, 0, 0, 10, 0, 12, 2, 702, 0, 0, 340, 4, 0, 4, 11, 16, 3, 0, 5, 18, 0, 78, 4, 2, 7, 0, 0, 0, 576, 1, 0, 1, 22, 0, 0, 3, 11, 14, 29, 5, 0, 15, 5, 0, 4, 0, 3, 2, 5, 0, 7, 11, 77, 17, 9, 6, 356, 51, 1, 8, 2, 24, 1, 8, 2, 0, 4, 0, 2, 1, 0, 11, 10, 1, 95, 14, 18, 5, 1, 2, 29, 0, 1, 3, 4, 1, 32, 4, 0, 8, 3, 0, 19, 4, 0, 9, 0, 0, 3, 51, 10, 0, 0, 3, 26, 0, 55, 2, 0, 7, 56, 0, 1, 32, 5, 0, 0, 3, 2, 1, 4, 8, 10, 0, 10, 0, 1, 10, 22, 5, 1, 5, 1, 6, 3, 1, 8, 0, 0, 4, 1, 527, 4, 0, 1, 29, 0, 6, 5, 11, 7, 90, 14, 0, 1, 69, 5, 7, 7, 17, 94, 12, 49, 1, 0, 2, 5, 3, 0, 3, 14, 2, 0, 118, 9, 3, 3, 0, 19, 1, 10, 1, 25, 8, 295, 0, 1, 1, 2, 2, 6, 6, 0, 1, 2, 18, 43, 17, 0, 0, 0, 7, 1, 5, 0, 3, 3, 25, 1, 15, 19, 9, 13, 2, 7, 0, 12, 0, 0, 2, 6, 4, 2, 0, 1, 0, 3, 1, 36, 2, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 7, 1, 0, 4, 11, 4, 9, 0, 18, 0, 2, 5, 2, 2, 0, 8, 3, 4, 6, 7, 11, 37, 0, 46, 3, 3, 0, 15, 4, 2, 461, 16, 1, 5, 34, 45, 38, 5, 11, 1, 1, 0, 7, 0, 0, 1, 0, 21, 21, 9, 1, 5, 8, 10, 0, 35, 23, 2, 0, 0, 23, 0, 3, 16, 1, 33, 12, 6, 3, 2, 2, 8, 4, 0, 9, 0, 8, 2, 17, 3, 0, 1, 54, 2, 8, 1, 8, 7, 11, 0, 2, 0, 0, 5, 1, 13, 10, 2, 0, 0, 1, 7, 13, 26, 9, 0, 0, 12, 0, 0, 5, 5, 16, 11, 2, 44, 8, 0, 6, 0, 20, 9, 0, 3, 10, 23, 1, 1, 0, 46, 3, 13, 2, 0, 4, 1, 2, 0, 6, 9, 6, 1, 2, 1, 4, 404, 4, 4, 27, 1, 1, 0, 1, 6, 11, 0, 1, 47, 0, 3, 0, 0, 4, 11, 4, 14, 0, 2, 0, 1, 137, 0, 0, 31, 5, 0, 2, 12, 3, 26, 3, 35, 2, 0, 8, 10, 4, 0, 1, 17, 0, 5, 3, 1, 6, 13, 0]
2019-04-12 12:50:05,757 INFO fr.inria.main.evolution.AstorMain - Time Total(s): 2171.295
[DONE]
