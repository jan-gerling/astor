2019-04-12 14:36:40,459 INFO main - command line arguments: [-jvm4testexecution  /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin  -mode  jgenprog  -scope  package  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -location  defect4j_tests/math_76/  -dependencies  ./examples/libs/junit-4.4.jar  -flthreshold  0.5  -maxtime  100  -stopfirst  true]
2019-04-12 14:36:43,657 INFO main - -Executing Gzoltar classpath: /home/jan_gerling/astor/./outputMutation/AstorMain-math_76//bin//default from 230 classes with test cases
2019-04-12 14:36:43,657 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar fault localization: min susp value parameter: 0.5
2019-04-12 14:36:45,637 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - -gz-Adding classpath: [/home/jan_gerling/astor/./examples/libs/junit-4.4.jar, /home/jan_gerling/astor/./outputMutation/AstorMain-math_76//bin//default]
2019-04-12 14:37:17,916 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.SingularValueSolverTest#testMath320A
2019-04-12 14:37:17,916 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.SingularValueSolverTest#testMath320B
2019-04-12 14:37:17,921 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar Test Result Total:2135, fails: 2, GZoltar suspicious 17322
2019-04-12 14:37:17,960 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar found: 7 with susp > 0.5, we consider: 7
2019-04-12 14:37:18,018 INFO main - building model: /home/jan_gerling/astor/./outputMutation/AstorMain-math_76//src//default, compliance level: 8
2019-04-12 14:37:36,836 INFO main - 
---- Initial suspicious size: 7
2019-04-12 14:37:37,005 INFO main - Total suspicious from FL: 7,  7
2019-04-12 14:37:37,005 INFO main - Total ModPoint created: 7
2019-04-12 14:37:37,005 INFO main - Creating program variant #1, [Variant id: 1, #gens: 7, #ops: 0, parent:-]
2019-04-12 14:37:37,144 INFO main - Total suspicious from FL: 7,  7
2019-04-12 14:37:37,144 INFO main - Total ModPoint created: 7
2019-04-12 14:37:37,144 INFO main - Creating program variant #2, [Variant id: 2, #gens: 7, #ops: 0, parent:-]
2019-04-12 14:37:37,239 INFO main - Total suspicious from FL: 7,  7
2019-04-12 14:37:37,239 INFO main - Total ModPoint created: 7
2019-04-12 14:37:37,239 INFO main - Creating program variant #3, [Variant id: 3, #gens: 7, #ops: 0, parent:-]
2019-04-12 14:38:46,691 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 14:38:46,691 INFO fr.inria.astor.core.setup.ConfigurationProperties - ---Configuration properties:---Execution values
2019-04-12 14:38:46,691 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:faultlocalization= fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization
2019-04-12 14:38:46,691 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:packageToInstrument= 
2019-04-12 14:38:46,691 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:flthreshold= 0.5
2019-04-12 14:38:46,691 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:numberExecutions= 1
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuiteresultfolder= evosuite
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoredTestCases= 
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:skipfaultlocalization= false
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxGeneration= 200
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxsuspcandidates= 1000
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax2= 960000
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax1= 120000
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:workingDirectory= /home/jan_gerling/astor/./outputMutation
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mode= jgenprog
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoreflakyinfl= false
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:uniqueoptogen= false
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pathToMVNRepository= 
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:timezone= America/Los_Angeles
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:applyCrossover= false
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clonegranularity= types
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:modificationpointnavigation= weight
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clusteringfilename= clustering.csv
2019-04-12 14:38:46,692 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxtime= 100
2019-04-12 14:38:46,693 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:probagenmutation= false
2019-04-12 14:38:46,693 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:alternativecompliancelevel= 4
2019-04-12 14:38:46,693 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:version-location= ./math-version/
2019-04-12 14:38:46,693 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:location= defect4j_tests/math_76/
2019-04-12 14:38:46,694 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:filterfaultlocalization= true
2019-04-12 14:38:46,694 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:stopfirst= true
2019-04-12 14:38:46,694 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4testexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 14:38:46,694 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bugId= 280
2019-04-12 14:38:46,694 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mutationrate= 1 
2019-04-12 14:38:46,694 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:forceExecuteRegression= false
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:projectIdentifier= 
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_buggy_class= true
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoRunOnBuggyClass= true
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resetoperations= false
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4evosuitetestexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:seed= 0
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:testbystep= false
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srctestfolder= /src/test/
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:javacompliancelevel= 8
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bintestfolder= /target/test-classes/
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:fitnessfunction= fr.inria.astor.core.loop.population.TestCaseFitnessFunction
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:commandTrunk= 50000
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:dependenciespath= ./examples/libs/junit-4.4.jar
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:multipointmodification= false
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:transformingredient= false
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:validation= process
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:scope= package
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitetimeout= 120
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoDSE= false
2019-04-12 14:38:46,695 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:elementsToMutate= 10
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:allpoints= false
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resourcesfolder= /src/main/resources:/src/test/resources:
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:regressionforfaultlocalization= true
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:population= 3
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:saveall= false
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pvariantfoldername= variant-
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:populationcontroller= fr.inria.astor.core.loop.population.TestCaseBasedFitnessPopulationController
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:savesolution= true
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srcjavafolder= /src/java/
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_affected_by_op= true
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:binjavafolder= /target/classes/
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:reintroduce= original-parents
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:learningdir= 
2019-04-12 14:38:46,696 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 14:38:46,696 INFO main - 
----Starting Solution Search
2019-04-12 14:39:03,193 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 14:39:03,193 ERROR main - Undo Error: original: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null) {
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		}
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null) {
			cachedVt = getV().transpose();
		}
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:03,197 ERROR main - Undo Error: modified: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null)
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null) {
			cachedVt = getV().transpose();
		}
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:14,068 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 14:39:14,068 ERROR main - Undo Error: original: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null)
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null) {
			cachedVt = getV().transpose();
		}
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:14,072 ERROR main - Undo Error: modified: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null)
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:15,607 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 14:39:15,607 ERROR main - Undo Error: original: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null) {
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		}
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null) {
			cachedVt = getV().transpose();
		}
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:15,611 ERROR main - Undo Error: modified: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null) {
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		}
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:16,475 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 14:39:16,475 ERROR main - Undo Error: original: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null) {
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		}
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:16,480 ERROR main - Undo Error: modified: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i)
					wData[i] = new double[p];
				
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null) {
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		}
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:26,489 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 14:39:26,489 ERROR main - Undo Error: original: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i) {
					wData[i] = new double[p];
				}
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null)
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:26,492 ERROR main - Undo Error: modified: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i)
					wData[i] = new double[p];
				
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null)
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:32,336 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 14:39:32,336 ERROR main - Undo Error: original: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i)
					wData[i] = new double[p];
				
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null) {
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		}
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:39:32,339 ERROR main - Undo Error: modified: 
public class SingularValueDecompositionImpl implements org.apache.commons.math.linear.SingularValueDecomposition {
	private int m;

	private int n;

	private org.apache.commons.math.linear.BiDiagonalTransformer transformer;

	private double[] mainBidiagonal;

	private double[] secondaryBidiagonal;

	private double[] mainTridiagonal;

	private double[] secondaryTridiagonal;

	private org.apache.commons.math.linear.EigenDecomposition eigenDecomposition;

	private double[] singularValues;

	private org.apache.commons.math.linear.RealMatrix cachedU;

	private org.apache.commons.math.linear.RealMatrix cachedUt;

	private org.apache.commons.math.linear.RealMatrix cachedS;

	private org.apache.commons.math.linear.RealMatrix cachedV;

	private org.apache.commons.math.linear.RealMatrix cachedVt;

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException {
		this(matrix, java.lang.Math.min(matrix.getRowDimension(), matrix.getColumnDimension()));
	}

	public SingularValueDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final int max) throws org.apache.commons.math.linear.InvalidMatrixException {
		m = matrix.getRowDimension();
		n = matrix.getColumnDimension();
		cachedU = null;
		cachedS = null;
		cachedV = null;
		cachedVt = null;
		transformer = new org.apache.commons.math.linear.BiDiagonalTransformer(matrix);
		mainBidiagonal = transformer.getMainDiagonalRef();
		secondaryBidiagonal = transformer.getSecondaryDiagonalRef();
		mainTridiagonal = new double[mainBidiagonal.length];
		secondaryTridiagonal = new double[(mainBidiagonal.length) - 1];
		double a = mainBidiagonal[0];
		mainTridiagonal[0] = a * a;
		for (int i = 1; i < (mainBidiagonal.length); ++i) {
			final double b = secondaryBidiagonal[(i - 1)];
			secondaryTridiagonal[(i - 1)] = a * b;
			a = mainBidiagonal[i];
			mainTridiagonal[i] = (a * a) + (b * b);
		}
		eigenDecomposition = new org.apache.commons.math.linear.EigenDecompositionImpl(mainTridiagonal, secondaryTridiagonal, org.apache.commons.math.util.MathUtils.SAFE_MIN);
		final double[] eigenValues = eigenDecomposition.getRealEigenvalues();
		int p = java.lang.Math.min(max, eigenValues.length);
		while ((p > 0) && ((eigenValues[(p - 1)]) <= 0)) {
			--p;
		} 
		singularValues = new double[p];
		for (int i = 0; i < p; ++i) {
			singularValues[i] = java.lang.Math.sqrt(eigenValues[i]);
		}
	}

	public org.apache.commons.math.linear.RealMatrix getU() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedU) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[m][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (m); ++i)
					wData[i] = new double[p];
				
				cachedU = transformer.getU().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((m) - 1), 0, (p - 1));
				cachedU = transformer.getU().multiply(e);
			}
		}
		return cachedU;
	}

	public org.apache.commons.math.linear.RealMatrix getUT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedUt) == null) {
			cachedUt = getU().transpose();
		}
		return cachedUt;
	}

	public org.apache.commons.math.linear.RealMatrix getS() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedS) == null)
			cachedS = org.apache.commons.math.linear.MatrixUtils.createRealDiagonalMatrix(singularValues);
		
		return cachedS;
	}

	public double[] getSingularValues() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues.clone();
	}

	public org.apache.commons.math.linear.RealMatrix getV() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedV) == null) {
			final int p = singularValues.length;
			if ((m) >= (n)) {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, ((n) - 1), 0, (p - 1));
				cachedV = transformer.getV().multiply(e);
			}else {
				final org.apache.commons.math.linear.RealMatrix e = eigenDecomposition.getV().getSubMatrix(0, (p - 1), 0, (p - 1));
				final double[][] eData = e.getData();
				final double[][] wData = new double[n][p];
				double[] ei1 = eData[0];
				for (int i = 0; i < (p - 1); ++i) {
					final double mi = mainBidiagonal[i];
					final double[] ei0 = ei1;
					final double[] wi = wData[i];
					ei1 = eData[(i + 1)];
					final double si = secondaryBidiagonal[i];
					for (int j = 0; j < p; ++j) {
						wi[j] = ((mi * (ei0[j])) + (si * (ei1[j]))) / (singularValues[j]);
					}
				}
				for (int j = 0; j < p; ++j) {
					wData[(p - 1)][j] = ((ei1[j]) * (mainBidiagonal[(p - 1)])) / (singularValues[j]);
				}
				for (int i = p; i < (n); ++i) {
					wData[i] = new double[p];
				}
				cachedV = transformer.getV().multiply(org.apache.commons.math.linear.MatrixUtils.createRealMatrix(wData));
			}
		}
		return cachedV;
	}

	public org.apache.commons.math.linear.RealMatrix getVT() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((cachedVt) == null)
			cachedVt = getV().transpose();
		
		return cachedVt;
	}

	public org.apache.commons.math.linear.RealMatrix getCovariance(final double minSingularValue) {
		final int p = singularValues.length;
		int dimension = 0;
		while ((dimension < p) && ((singularValues[dimension]) >= minSingularValue)) {
			++dimension;
		} 
		if (dimension == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("cutoff singular value is {0}, should be at most {1}", minSingularValue, singularValues[0]);
		}
		final double[][] data = new double[dimension][p];
		getVT().walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				data[row][column] = value / (singularValues[row]);
			}
		}, 0, (dimension - 1), 0, (p - 1));
		org.apache.commons.math.linear.RealMatrix jv = new org.apache.commons.math.linear.Array2DRowRealMatrix(data, false);
		return jv.transpose().multiply(jv);
	}

	public double getNorm() throws org.apache.commons.math.linear.InvalidMatrixException {
		return singularValues[0];
	}

	public double getConditionNumber() throws org.apache.commons.math.linear.InvalidMatrixException {
		return (singularValues[0]) / (singularValues[((singularValues.length) - 1)]);
	}

	public int getRank() throws java.lang.IllegalStateException {
		final double threshold = (java.lang.Math.max(m, n)) * (java.lang.Math.ulp(singularValues[0]));
		for (int i = (singularValues.length) - 1; i >= 0; --i) {
			if ((singularValues[i]) > threshold) {
				return i + 1;
			}
		}
		return 0;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.SingularValueDecompositionImpl.Solver(singularValues, getUT(), getV(), ((getRank()) == (java.lang.Math.max(m, n))));
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final org.apache.commons.math.linear.RealMatrix pseudoInverse;

		private boolean nonSingular;

		private Solver(final double[] singularValues, final org.apache.commons.math.linear.RealMatrix uT, final org.apache.commons.math.linear.RealMatrix v, final boolean nonSingular) {
			double[][] suT = uT.getData();
			for (int i = 0; i < (singularValues.length); ++i) {
				final double a = 1.0 / (singularValues[i]);
				final double[] suTi = suT[i];
				for (int j = 0; j < (suTi.length); ++j) {
					suTi[j] *= a;
				}
			}
			pseudoInverse = v.multiply(new org.apache.commons.math.linear.Array2DRowRealMatrix(suT, false));
			this.nonSingular = nonSingular;
		}

		public double[] solve(final double[] b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealVector solve(final org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.operate(b);
		}

		public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException {
			return pseudoInverse.multiply(b);
		}

		public boolean isNonSingular() {
			return nonSingular;
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() {
			return pseudoInverse;
		}
	}
}
2019-04-12 14:54:27,520 INFO main - Time Repair Loop (s): 940.824
2019-04-12 14:54:27,520 INFO main - 
----SUMMARY_EXECUTION---
2019-04-12 14:54:27,520 INFO main - 
successful_ing_attempts (0): []
2019-04-12 14:54:27,521 INFO main - 
failing_ing_attempts (600): [28, 79, 78, 0, 21, 0, 0, 0, 0, 1, 0, 2, 28, 5, 0, 14, 0, 47, 0, 0, 0, 14, 12, 10, 5, 21, 23, 18, 6, 64, 0, 3, 6, 0, 27, 1, 57, 2, 0, 0, 0, 12, 4, 0, 0, 16, 5, 3, 2, 0, 0, 0, 18, 5, 5, 76, 65, 38, 0, 0, 66, 3, 0, 23, 18, 0, 0, 11, 33, 14, 0, 0, 2, 0, 11, 10, 10, 81, 9, 5, 2, 4, 15, 11, 20, 0, 5, 3, 19, 7, 11, 0, 11, 0, 4, 0, 2, 58, 20, 184, 4, 0, 6, 9, 0, 3, 0, 10, 22, 5, 0, 0, 0, 5, 0, 36, 12, 1, 1, 0, 15, 8, 3, 11, 1, 0, 0, 10, 0, 0, 0, 0, 11, 1, 4, 11, 8, 30, 5, 1, 17, 26, 11, 5, 4, 12, 43, 4, 1, 2, 0, 8, 15, 20, 51, 7, 3, 7, 2, 9, 6, 3, 6, 16, 11, 23, 6, 0, 2, 12, 32, 0, 0, 0, 24, 0, 9, 44, 27, 0, 8, 23, 0, 0, 85, 0, 14, 0, 5, 8, 0, 9, 11, 1, 4, 0, 14, 6, 43, 23, 3, 11, 1, 40, 0, 56, 4, 38, 46, 3, 0, 0, 24, 6, 1, 4, 40, 0, 0, 0, 5, 35, 44, 137, 36, 10, 11, 48, 21, 0, 2, 10, 0, 20, 10, 0, 0, 7, 1, 10, 0, 3, 56, 0, 0, 12, 2, 15, 0, 5, 0, 6, 11, 47, 0, 18, 13, 31, 3, 10, 8, 0, 0, 14, 0, 49, 52, 0, 2, 5, 0, 5, 11, 5, 0, 5, 0, 4, 55, 35, 27, 15, 3, 7, 0, 5, 11, 8, 3, 0, 5, 8, 12, 0, 4, 0, 1, 36, 16, 46, 4, 11, 28, 17, 39, 6, 0, 6, 1, 49, 10, 2, 23, 0, 4, 4, 8, 1, 7, 90, 24, 0, 9, 0, 0, 0, 40, 0, 8, 2, 5, 5, 3, 4, 0, 6, 0, 15, 28, 5, 17, 3, 4, 10, 23, 2, 1, 3, 24, 14, 0, 15, 15, 8, 8, 15, 0, 0, 3, 33, 8, 1, 5, 0, 21, 3, 4, 11, 3, 9, 45, 1, 29, 0, 1, 3, 0, 24, 5, 2, 2, 34, 23, 0, 7, 1, 52, 5, 14, 68, 6, 0, 14, 49, 10, 2, 15, 1, 11, 9, 0, 8, 8, 71, 11, 3, 0, 5, 0, 2, 3, 0, 14, 1, 14, 0, 7, 0, 42, 12, 7, 1, 2, 33, 9, 5, 3, 1, 32, 1, 1, 0, 0, 4, 57, 0, 9, 9, 0, 0, 17, 0, 0, 0, 0, 5, 17, 16, 8, 6, 1, 2, 5, 0, 5, 2, 1, 9, 0, 0, 5, 3, 0, 3, 18, 17, 3, 3, 13, 11, 3, 25, 0, 12, 0, 5, 0, 0, 43, 9, 16, 13, 0, 0, 0, 2, 28, 1, 9, 0, 11, 6, 38, 0, 31, 7, 1, 1, 2, 56, 6, 5, 0, 0, 5, 0, 1, 0, 18, 20, 9, 2, 0, 7, 0, 14, 0, 0, 8, 4, 4, 3, 9, 116, 0, 5, 22, 0, 0, 27, 1, 1, 0, 0, 15, 5, 27, 0, 3, 3, 16, 5, 22, 0, 44, 3, 2, 7, 0, 35, 19, 13, 6, 2, 22, 7, 17, 28, 22, 0, 13, 5, 8, 0, 20, 2, 0, 30, 0, 32, 5, 6, 2, 67, 0, 1, 0, 19, 0, 12, 4, 27, 0, 16, 7, 21, 3, 0, 4, 3, 0, 0, 0, 1, 6, 6, 2, 0, 2, 0]
2019-04-12 14:54:27,521 INFO fr.inria.main.evolution.AstorMain - Time Total(s): 1067.032
[DONE]
