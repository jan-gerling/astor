2019-04-12 11:32:33,962 INFO main - command line arguments: [-jvm4testexecution  /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin  -mode  jgenprog  -scope  package  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -location  defect4j_tests/math_86/  -dependencies  ./examples/libs/junit-4.4.jar  -flthreshold  0.5  -maxtime  100  -stopfirst  true]
2019-04-12 11:32:37,142 INFO main - -Executing Gzoltar classpath: /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//bin//default from 194 classes with test cases
2019-04-12 11:32:37,142 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar fault localization: min susp value parameter: 0.5
2019-04-12 11:32:38,876 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - -gz-Adding classpath: [/home/jan_gerling/astor/./examples/libs/junit-4.4.jar, /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//bin//default]
2019-04-12 11:33:01,265 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274
2019-04-12 11:33:01,271 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite
2019-04-12 11:33:01,294 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar Test Result Total:1894, fails: 2, GZoltar suspicious 15671
2019-04-12 11:33:01,435 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar found: 1000 with susp > 0.5, we consider: 1000
2019-04-12 11:33:01,464 INFO main - building model: /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//src//default, compliance level: 8
2019-04-12 11:33:18,108 INFO main - 
---- Initial suspicious size: 994
2019-04-12 11:33:21,399 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 11:33:22,491 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 11:33:22,792 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 11:33:23,066 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 11:33:23,159 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:23,178 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:23,198 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:23,205 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:33:23,256 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:23,259 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:33:23,344 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 11:33:23,415 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 11:33:23,430 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:23,447 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:23,468 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:33:23,472 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:23,474 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:23,475 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:23,476 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 11:33:23,500 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 11:33:23,545 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 11:33:23,565 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 11:33:23,583 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:23,585 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:33:23,637 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 11:33:23,644 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 11:33:23,653 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 11:33:23,679 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 11:33:23,701 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:33:23,702 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:33:23,702 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:23,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:23,703 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:23,715 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:23,716 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:33:23,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:33:23,717 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:33:23,717 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:33:23,718 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:33:23,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:33:23,722 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:23,736 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:23,752 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:23,944 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 11:33:23,972 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:23,972 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:23,972 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:33:23,972 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:33:23,972 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:33:23,972 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:33:23,972 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:33:23,972 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:33:24,098 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 11:33:24,101 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 11:33:24,119 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 11:33:24,153 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 11:33:24,273 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 11:33:24,418 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:33:24,512 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:24,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 11:33:24,601 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 11:33:24,696 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:24,742 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:24,782 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:25,585 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 11:33:25,587 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 11:33:25,637 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 11:33:25,639 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:33:25,694 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 11:33:25,697 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 11:33:25,710 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 11:33:25,715 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 11:33:25,719 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 11:33:25,746 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 11:33:25,815 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:25,870 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:25,890 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 11:33:25,896 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 11:33:25,923 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 11:33:25,939 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 11:33:25,997 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 11:33:26,005 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 11:33:26,006 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:33:26,006 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:33:26,006 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:33:26,006 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:33:26,006 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:33:26,006 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:33:26,006 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:33:26,016 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:33:26,016 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:33:26,016 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:33:26,016 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:33:26,016 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:33:26,016 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:33:26,016 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:33:26,016 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:33:26,016 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:33:26,016 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:33:26,016 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:33:26,551 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 11:33:26,573 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 11:33:26,640 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 11:33:26,642 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:26,645 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:26,935 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 11:33:26,970 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 11:33:26,995 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 11:33:27,055 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 11:33:27,144 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 11:33:27,167 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 11:33:27,172 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 11:33:27,189 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 11:33:27,248 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 11:33:27,288 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 11:33:27,415 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 11:33:27,458 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 11:33:27,469 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 11:33:27,491 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 11:33:27,621 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 11:33:27,824 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 11:33:27,881 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 11:33:27,910 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 11:33:27,995 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 11:33:28,069 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 11:33:28,190 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 11:33:28,216 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 11:33:28,270 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 11:33:28,275 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 11:33:28,447 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 11:33:28,467 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:28,467 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:28,467 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:28,467 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:28,467 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:33:28,468 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:33:28,472 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:28,472 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:28,489 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:33:28,490 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:33:28,490 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:28,490 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:28,514 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 11:33:28,528 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 11:33:28,547 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 11:33:28,557 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 11:33:28,571 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 11:33:28,602 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 11:33:28,616 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 11:33:28,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 11:33:28,630 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 11:33:28,633 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 11:33:28,736 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 11:33:28,811 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 11:33:28,831 INFO main - Total suspicious from FL: 994,  811
2019-04-12 11:33:28,831 INFO main - Total ModPoint created: 811
2019-04-12 11:33:28,831 INFO main - Creating program variant #1, [Variant id: 1, #gens: 811, #ops: 0, parent:-]
2019-04-12 11:33:29,979 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 11:33:30,858 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 11:33:31,082 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 11:33:31,321 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 11:33:31,414 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:31,430 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:31,434 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:31,436 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:33:31,460 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:31,467 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:33:31,520 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 11:33:31,609 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 11:33:31,612 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:31,628 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:31,630 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:33:31,633 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:31,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:31,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:31,649 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 11:33:31,658 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 11:33:31,699 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 11:33:31,704 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 11:33:31,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:31,726 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:33:31,753 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 11:33:31,757 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 11:33:31,781 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 11:33:31,804 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 11:33:31,824 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:31,825 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:31,825 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:31,825 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:33:31,825 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:31,825 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:33:31,825 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:33:31,825 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:33:31,825 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:33:31,826 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:33:31,826 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:33:31,826 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:31,826 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:31,826 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:33:31,826 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:33:31,826 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:33:31,826 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:33:31,826 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:31,826 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:31,826 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:33:31,826 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:33:31,826 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:33:31,826 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:33:31,827 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:33:31,827 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:33:31,828 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:31,828 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:31,829 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:31,829 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:31,834 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:33:31,835 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:33:31,835 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:33:31,836 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:33:31,836 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:33:31,836 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:33:31,836 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:33:31,836 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:33:31,836 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:33:31,838 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:31,842 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:31,850 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:32,056 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 11:33:32,082 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:32,082 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:32,082 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:33:32,082 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:33:32,082 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:33:32,082 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:33:32,082 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:33:32,082 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:33:32,151 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 11:33:32,166 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 11:33:32,196 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 11:33:32,244 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 11:33:32,318 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 11:33:32,428 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:33:32,455 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:32,497 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 11:33:32,499 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 11:33:32,587 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:32,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:32,669 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:33,293 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 11:33:33,294 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 11:33:33,316 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 11:33:33,318 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:33:33,338 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 11:33:33,340 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 11:33:33,342 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 11:33:33,345 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 11:33:33,351 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 11:33:33,377 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 11:33:33,440 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:33,481 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:33,492 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 11:33:33,497 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 11:33:33,510 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 11:33:33,514 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 11:33:33,540 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 11:33:33,543 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:33:33,544 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:33:33,544 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:33:33,851 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 11:33:33,858 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 11:33:33,900 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 11:33:33,902 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:33,904 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:34,174 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 11:33:34,182 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 11:33:34,209 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 11:33:34,308 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 11:33:34,436 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 11:33:34,456 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 11:33:34,460 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 11:33:34,473 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 11:33:34,521 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 11:33:34,545 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 11:33:34,716 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 11:33:34,769 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 11:33:34,787 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 11:33:34,807 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 11:33:34,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 11:33:35,014 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 11:33:35,074 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 11:33:35,098 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 11:33:35,156 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 11:33:35,220 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 11:33:35,327 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 11:33:35,355 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 11:33:35,442 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 11:33:35,446 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 11:33:35,628 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 11:33:35,634 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:35,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:35,634 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:35,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:35,634 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:33:35,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:33:35,634 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:35,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:35,634 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:33:35,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:33:35,634 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:35,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:35,688 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 11:33:35,713 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 11:33:35,733 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 11:33:35,753 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 11:33:35,777 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 11:33:35,823 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 11:33:35,839 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 11:33:35,864 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 11:33:35,869 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 11:33:35,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 11:33:35,951 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 11:33:36,020 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 11:33:36,035 INFO main - Total suspicious from FL: 994,  811
2019-04-12 11:33:36,035 INFO main - Total ModPoint created: 811
2019-04-12 11:33:36,035 INFO main - Creating program variant #2, [Variant id: 2, #gens: 811, #ops: 0, parent:-]
2019-04-12 11:33:37,194 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 11:33:37,976 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 11:33:38,153 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 11:33:38,289 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 11:33:38,370 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:38,374 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:38,396 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:38,398 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:33:38,433 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:38,435 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:33:38,509 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 11:33:38,597 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 11:33:38,600 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:38,617 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:38,619 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:33:38,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:38,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:38,624 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:38,625 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 11:33:38,634 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 11:33:38,650 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 11:33:38,655 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 11:33:38,659 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:38,661 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:33:38,675 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 11:33:38,680 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 11:33:38,687 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 11:33:38,698 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 11:33:38,706 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:38,706 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:38,706 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:38,706 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:38,706 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:38,706 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:33:38,707 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:38,707 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:33:38,708 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:33:38,708 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:33:38,711 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:33:38,713 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:38,721 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:33:38,808 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 11:33:38,858 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:38,858 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:38,858 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:33:38,858 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:33:38,858 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:33:38,858 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:33:38,858 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:33:38,858 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:33:38,911 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 11:33:38,913 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 11:33:38,929 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 11:33:38,952 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 11:33:39,050 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 11:33:39,142 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:33:39,156 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:33:39,184 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 11:33:39,187 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 11:33:39,270 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:39,318 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:39,360 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:39,954 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 11:33:39,958 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 11:33:40,007 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 11:33:40,009 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:33:40,060 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 11:33:40,062 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 11:33:40,065 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 11:33:40,069 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 11:33:40,073 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 11:33:40,109 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 11:33:40,160 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:40,178 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:33:40,189 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 11:33:40,194 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 11:33:40,209 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 11:33:40,213 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 11:33:40,278 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:33:40,282 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:33:40,282 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:33:40,665 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 11:33:40,685 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 11:33:40,723 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 11:33:40,724 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:40,725 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:33:40,882 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 11:33:40,889 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 11:33:40,901 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 11:33:40,971 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 11:33:41,074 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 11:33:41,081 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 11:33:41,085 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 11:33:41,088 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 11:33:41,111 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 11:33:41,122 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 11:33:41,197 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 11:33:41,224 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 11:33:41,232 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 11:33:41,239 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 11:33:41,297 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 11:33:41,405 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 11:33:41,531 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 11:33:41,559 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 11:33:41,644 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 11:33:41,696 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 11:33:41,750 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 11:33:41,774 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 11:33:41,832 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 11:33:41,836 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 11:33:41,915 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 11:33:41,921 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:41,921 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:33:41,921 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:41,921 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:33:41,921 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:33:41,921 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:33:41,921 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:41,921 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:33:41,921 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:33:41,921 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:33:41,921 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:41,921 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:33:41,941 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 11:33:41,952 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 11:33:41,980 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 11:33:42,000 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 11:33:42,022 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 11:33:42,058 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 11:33:42,069 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 11:33:42,074 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 11:33:42,079 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 11:33:42,083 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 11:33:42,151 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 11:33:42,227 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 11:33:42,232 INFO main - Total suspicious from FL: 994,  811
2019-04-12 11:33:42,232 INFO main - Total ModPoint created: 811
2019-04-12 11:33:42,232 INFO main - Creating program variant #3, [Variant id: 3, #gens: 811, #ops: 0, parent:-]
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - ---Configuration properties:---Execution values
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:faultlocalization= fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:packageToInstrument= 
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:flthreshold= 0.5
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:numberExecutions= 1
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuiteresultfolder= evosuite
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoredTestCases= 
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:skipfaultlocalization= false
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxGeneration= 200
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxsuspcandidates= 1000
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax2= 960000
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax1= 120000
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:workingDirectory= /home/jan_gerling/astor/./outputMutation
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mode= jgenprog
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoreflakyinfl= false
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:uniqueoptogen= false
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pathToMVNRepository= 
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:timezone= America/Los_Angeles
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:applyCrossover= false
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clonegranularity= types
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:modificationpointnavigation= weight
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clusteringfilename= clustering.csv
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxtime= 100
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:probagenmutation= false
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:alternativecompliancelevel= 4
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:version-location= ./math-version/
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:location= defect4j_tests/math_86/
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:filterfaultlocalization= true
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:stopfirst= true
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4testexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bugId= 280
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mutationrate= 1 
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:forceExecuteRegression= false
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:projectIdentifier= 
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_buggy_class= true
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoRunOnBuggyClass= true
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resetoperations= false
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4evosuitetestexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:seed= 0
2019-04-12 11:35:17,057 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:testbystep= false
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srctestfolder= /src/test/
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:javacompliancelevel= 8
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bintestfolder= /target/test-classes/
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:fitnessfunction= fr.inria.astor.core.loop.population.TestCaseFitnessFunction
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:commandTrunk= 50000
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:dependenciespath= ./examples/libs/junit-4.4.jar
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:multipointmodification= false
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:transformingredient= false
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:validation= process
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:scope= package
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitetimeout= 120
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoDSE= false
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:elementsToMutate= 10
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:allpoints= false
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resourcesfolder= /src/main/resources:/src/test/resources:
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:regressionforfaultlocalization= true
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:population= 3
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:saveall= false
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pvariantfoldername= variant-
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:populationcontroller= fr.inria.astor.core.loop.population.TestCaseBasedFitnessPopulationController
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:savesolution= true
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srcjavafolder= /src/java/
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_affected_by_op= true
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:binjavafolder= /target/classes/
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:reintroduce= original-parents
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:learningdir= 
2019-04-12 11:35:17,058 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 11:35:17,058 INFO main - 
----Starting Solution Search
2019-04-12 11:41:13,199 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:41:13,199 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:41:13,205 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:45:45,714 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:45:45,714 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null) {
			cachedL = getLT().transpose();
		}
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:45:45,716 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:48:06,236 INFO main - The Process that runs JUnit test cases had problems: process hasn't exited
2019-04-12 11:48:40,287 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:48:40,287 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:48:40,293 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:53:10,625 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:53:10,626 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:53:10,631 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:53:17,069 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:53:17,069 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:53:17,075 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:53:51,237 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:53:51,237 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:53:51,239 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null)
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:56:23,937 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:56:23,937 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null) {
			cachedL = getLT().transpose();
		}
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:56:23,939 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:56:44,967 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:56:44,967 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:56:44,985 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:57:43,174 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:57:43,174 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:57:43,193 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null)
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:59:30,729 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:59:30,729 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:59:30,772 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:03:54,619 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:03:54,619 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:03:54,651 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 12:13:52,618 INFO main - Time Repair Loop (s): 2315.56
2019-04-12 12:13:52,618 INFO main - 
----SUMMARY_EXECUTION---
2019-04-12 12:13:52,618 INFO main - 
successful_ing_attempts (0): []
2019-04-12 12:13:52,618 INFO main - 
failing_ing_attempts (600): [30, 1, 3, 3, 33, 0, 0, 0, 23, 41, 7, 0, 13, 0, 0, 7, 31, 19, 6, 0, 4, 0, 3, 0, 44, 0, 1, 2, 8, 16, 3, 103, 0, 25, 31, 12, 14, 4, 72, 15, 3, 1, 0, 7, 13, 40, 0, 43, 17, 0, 5, 1, 10, 11, 0, 0, 5, 372, 0, 10, 36, 1, 32, 24, 0, 0, 6, 15, 16, 2, 45, 7, 9, 0, 82, 5, 240, 0, 0, 3, 8, 17, 0, 0, 1, 52, 8, 4, 464, 0, 10, 3, 13, 0, 5, 6, 5, 12, 123, 6, 11, 50, 22, 23, 2, 10, 4, 2, 10, 59, 39, 18, 0, 10, 11, 6, 0, 0, 29, 14, 14, 3, 33, 0, 5, 0, 8, 5, 17, 0, 1, 5, 0, 12, 1, 4, 2, 44, 9, 5, 0, 29, 7, 0, 3, 0, 20, 2, 13, 17, 45, 4, 19, 23, 21, 1, 9, 1, 17, 6, 22, 43, 32, 19, 13, 7, 0, 0, 4, 29, 0, 45, 19, 0, 6, 0, 6, 11, 10, 8, 10, 7, 1, 12, 9, 32, 4, 1, 30, 18, 12, 0, 19, 0, 8, 1, 0, 6, 8, 1, 6, 0, 0, 4, 5, 0, 15, 51, 1, 0, 23, 18, 0, 27, 0, 0, 18, 22, 1, 23, 22, 0, 21, 33, 1, 2, 19, 28, 0, 3, 15, 0, 4, 30, 7, 3, 0, 1, 1, 5, 1, 51, 4, 13, 1, 27, 13, 74, 19, 14, 0, 19, 0, 0, 0, 0, 0, 1, 12, 0, 6, 11, 9, 23, 0, 14, 0, 26, 0, 0, 6, 16, 9, 10, 0, 12, 0, 23, 14, 47, 15, 2, 3, 5, 6, 0, 0, 16, 38, 75, 11, 0, 14, 30, 4, 3, 57, 14, 7, 13, 10, 23, 32, 0, 20, 47, 17, 2, 0, 0, 11, 2, 2, 4, 4, 0, 1, 14, 10, 4, 0, 1, 47, 3, 0, 109, 0, 3, 17, 0, 52, 0, 0, 4, 62, 0, 0, 0, 36, 0, 11, 12, 2, 0, 7, 19, 1, 0, 28, 8, 9, 0, 6, 32, 22, 0, 5, 0, 20, 30, 13, 5, 1, 353, 19, 7, 0, 7, 17, 0, 19, 0, 0, 6, 5, 2, 1, 1, 0, 4, 11, 2, 17, 30, 11, 1, 0, 11, 16, 41, 33, 2, 5, 3, 1, 0, 0, 9, 9, 0, 3, 3, 23, 3, 5, 45, 12, 4, 12, 13, 33, 49, 31, 0, 1, 3, 30, 13, 5, 6, 3, 1, 21, 0, 5, 0, 2, 14, 2, 4, 3, 7, 0, 4, 7, 4, 9, 25, 287, 14, 6, 0, 0, 0, 10, 27, 20, 20, 52, 1, 0, 13, 2, 22, 0, 0, 26, 0, 16, 9, 31, 42, 9, 3, 0, 3, 5, 66, 7, 12, 0, 0, 15, 5, 1, 0, 62, 64, 12, 19, 35, 12, 39, 9, 30, 8, 0, 1, 0, 38, 7, 29, 0, 5, 0, 0, 7, 31, 56, 16, 277, 0, 2, 0, 18, 7, 3, 8, 0, 70, 8, 55, 20, 0, 0, 31, 9, 310, 0, 22, 11, 10, 17, 44, 4, 5, 0, 0, 29, 1, 57, 36, 4, 14, 32, 8, 6, 0, 2, 0, 22, 2, 0, 3, 12, 12, 19, 27, 10, 15, 12, 0, 6, 16, 2, 5, 22, 0, 10, 4, 471, 0, 2, 0, 0, 15, 7, 4, 0, 0, 50, 5, 0, 0, 37, 39, 12, 3, 0, 0, 5, 12, 0, 0, 8, 0, 30, 0, 23, 1, 1, 1, 11, 64, 0, 22, 30, 25, 23, 3]
2019-04-12 12:13:52,618 INFO fr.inria.main.evolution.AstorMain - Time Total(s): 2478.638
[DONE]
