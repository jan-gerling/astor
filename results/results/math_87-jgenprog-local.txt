2019-04-12 12:56:40,653 INFO main - command line arguments: [-jvm4testexecution  /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin  -mode  jgenprog  -scope  local  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -location  defect4j_tests/math_87/  -dependencies  ./examples/libs/junit-4.4.jar  -flthreshold  0.5  -maxtime  100  -stopfirst  true]
2019-04-12 12:56:43,343 INFO main - -Executing Gzoltar classpath: /home/jan_gerling/astor/./outputMutation/AstorMain-math_87//bin//default from 194 classes with test cases
2019-04-12 12:56:43,343 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar fault localization: min susp value parameter: 0.5
2019-04-12 12:56:45,248 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - -gz-Adding classpath: [/home/jan_gerling/astor/./examples/libs/junit-4.4.jar, /home/jan_gerling/astor/./outputMutation/AstorMain-math_87//bin//default]
2019-04-12 12:57:08,861 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.optimization.linear.SimplexSolverTest#testSingleVariableAndConstraint
2019-04-12 12:57:08,875 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar Test Result Total:1893, fails: 1, GZoltar suspicious 15671
2019-04-12 12:57:08,906 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar found: 2 with susp > 0.5, we consider: 2
2019-04-12 12:57:08,938 INFO main - building model: /home/jan_gerling/astor/./outputMutation/AstorMain-math_87//src//default, compliance level: 8
2019-04-12 12:57:27,384 INFO main - 
---- Initial suspicious size: 2
2019-04-12 12:57:27,541 INFO main - Total suspicious from FL: 2,  2
2019-04-12 12:57:27,541 INFO main - Total ModPoint created: 2
2019-04-12 12:57:27,541 INFO main - Creating program variant #1, [Variant id: 1, #gens: 2, #ops: 0, parent:-]
2019-04-12 12:57:27,601 INFO main - Total suspicious from FL: 2,  2
2019-04-12 12:57:27,602 INFO main - Total ModPoint created: 2
2019-04-12 12:57:27,602 INFO main - Creating program variant #2, [Variant id: 2, #gens: 2, #ops: 0, parent:-]
2019-04-12 12:57:27,656 INFO main - Total suspicious from FL: 2,  2
2019-04-12 12:57:27,657 INFO main - Total ModPoint created: 2
2019-04-12 12:57:27,657 INFO main - Creating program variant #3, [Variant id: 3, #gens: 2, #ops: 0, parent:-]
2019-04-12 12:57:42,948 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - ---Configuration properties:---Execution values
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:faultlocalization= fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:packageToInstrument= 
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:flthreshold= 0.5
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:numberExecutions= 1
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuiteresultfolder= evosuite
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoredTestCases= 
2019-04-12 12:57:42,949 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:skipfaultlocalization= false
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxGeneration= 200
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxsuspcandidates= 1000
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax2= 960000
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax1= 120000
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:workingDirectory= /home/jan_gerling/astor/./outputMutation
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mode= jgenprog
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoreflakyinfl= false
2019-04-12 12:57:42,960 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:uniqueoptogen= false
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pathToMVNRepository= 
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:timezone= America/Los_Angeles
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:applyCrossover= false
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clonegranularity= types
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:modificationpointnavigation= weight
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clusteringfilename= clustering.csv
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxtime= 100
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:probagenmutation= false
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:alternativecompliancelevel= 4
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:version-location= ./math-version/
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:location= defect4j_tests/math_87/
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:filterfaultlocalization= true
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:stopfirst= true
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4testexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bugId= 280
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mutationrate= 1 
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:forceExecuteRegression= false
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:projectIdentifier= 
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_buggy_class= true
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoRunOnBuggyClass= true
2019-04-12 12:57:42,961 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resetoperations= false
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4evosuitetestexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:seed= 0
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:testbystep= false
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srctestfolder= /src/test/
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:javacompliancelevel= 8
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bintestfolder= /target/test-classes/
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:fitnessfunction= fr.inria.astor.core.loop.population.TestCaseFitnessFunction
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:commandTrunk= 50000
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:dependenciespath= ./examples/libs/junit-4.4.jar
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:multipointmodification= false
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:transformingredient= false
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:validation= process
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:scope= local
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitetimeout= 120
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoDSE= false
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:elementsToMutate= 10
2019-04-12 12:57:42,962 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:allpoints= false
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resourcesfolder= /src/main/resources:/src/test/resources:
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:regressionforfaultlocalization= true
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:population= 3
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:saveall= false
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pvariantfoldername= variant-
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:populationcontroller= fr.inria.astor.core.loop.population.TestCaseBasedFitnessPopulationController
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:savesolution= true
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srcjavafolder= /src/java/
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_affected_by_op= true
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:binjavafolder= /target/classes/
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:reintroduce= original-parents
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:learningdir= 
2019-04-12 12:57:42,963 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 12:57:42,963 INFO main - 
----Starting Solution Search
2019-04-12 12:57:45,064 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:57:45,071 ERROR main - Undo Error: original: 
class SimplexTableau implements java.io.Serializable {
	private static final long serialVersionUID = -1369660067587938365L;

	private final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f;

	private final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints;

	private final boolean restrictToNonNegative;

	protected transient org.apache.commons.math.linear.RealMatrix tableau;

	protected final int numDecisionVariables;

	protected final int numSlackVariables;

	protected int numArtificialVariables;

	protected final double epsilon;

	SimplexTableau(final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f, final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints, final org.apache.commons.math.optimization.GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {
		this.f = f;
		this.constraints = constraints;
		this.restrictToNonNegative = restrictToNonNegative;
		this.epsilon = epsilon;
		this.numDecisionVariables = (getNumVariables()) + (restrictToNonNegative ? 0 : 1);
		this.numSlackVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.LEQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.numArtificialVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.EQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(createTableau((goalType == (org.apache.commons.math.optimization.GoalType.MAXIMIZE))));
		initialize();
	}

	protected double[][] createTableau(final boolean maximize) {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> constraints = getNormalizedConstraints();
		int width = ((((numDecisionVariables) + (numSlackVariables)) + (numArtificialVariables)) + (getNumObjectiveFunctions())) + 1;
		int height = (constraints.size()) + (getNumObjectiveFunctions());
		double[][] matrix = new double[height][width];
		if ((getNumObjectiveFunctions()) == 2) {
			matrix[0][0] = -1;
		}
		int zIndex = ((getNumObjectiveFunctions()) == 1) ? 0 : 1;
		matrix[zIndex][zIndex] = (maximize) ? 1 : -1;
		org.apache.commons.math.linear.RealVector objectiveCoefficients = (maximize) ? f.getCoefficients().mapMultiply((-1)) : f.getCoefficients();
		copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
		matrix[zIndex][(width - 1)] = (maximize) ? f.getConstantTerm() : (-1) * (f.getConstantTerm());
		if (!(restrictToNonNegative)) {
			matrix[zIndex][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(objectiveCoefficients);
		}
		int slackVar = 0;
		int artificialVar = 0;
		for (int i = 0; i < (constraints.size()); i++) {
			org.apache.commons.math.optimization.linear.LinearConstraint constraint = constraints.get(i);
			int row = (getNumObjectiveFunctions()) + i;
			copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
			if (!(restrictToNonNegative)) {
				matrix[row][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(constraint.getCoefficients());
			}
			matrix[row][(width - 1)] = constraint.getValue();
			if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.LEQ)) {
				matrix[row][((getSlackVariableOffset()) + (slackVar++))] = 1;
			}else
				if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ)) {
					matrix[row][((getSlackVariableOffset()) + (slackVar++))] = -1;
				}
			
			if (((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.EQ)) || ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ))) {
				matrix[0][((getArtificialVariableOffset()) + artificialVar)] = 1;
				matrix[row][((getArtificialVariableOffset()) + (artificialVar++))] = 1;
			}
		}
		return matrix;
	}

	public int getNumVariables() {
		return f.getCoefficients().getDimension();
	}

	public java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> getNormalizedConstraints() {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> normalized = new java.util.ArrayList<org.apache.commons.math.optimization.linear.LinearConstraint>();
		for (org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			normalized.add(normalize(constraint));
		}
		return normalized;
	}

	private org.apache.commons.math.optimization.linear.LinearConstraint normalize(final org.apache.commons.math.optimization.linear.LinearConstraint constraint) {
		if ((constraint.getValue()) < 0) {
			return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients().mapMultiply((-1)), constraint.getRelationship().oppositeRelationship(), ((-1) * (constraint.getValue())));
		}
		return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());
	}

	protected final int getNumObjectiveFunctions() {
		return (this.numArtificialVariables) > 0 ? 2 : 1;
	}

	private int getConstraintTypeCounts(final org.apache.commons.math.optimization.linear.Relationship relationship) {
		int count = 0;
		for (final org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			if ((constraint.getRelationship()) == relationship) {
				++count;
			}
		}
		return count;
	}

	private void initialize() {
		for (int artificialVar = 0; artificialVar < (numArtificialVariables); artificialVar++) {
			int row = getBasicRow(((getArtificialVariableOffset()) + artificialVar));
			subtractRow(0, row, 1.0);
		}
	}

	protected static double getInvertedCoeffiecientSum(final org.apache.commons.math.linear.RealVector coefficients) {
		double sum = 0;
		for (double coefficient : coefficients.getData()) {
			sum -= coefficient;
		}
		return sum;
	}

	private java.lang.Integer getBasicRow(final int col) {
		java.lang.Integer row = null;
		for (int i = getNumObjectiveFunctions(); i < (getHeight()); i++) {
			if (!(org.apache.commons.math.util.MathUtils.equals(getEntry(i, col), 0.0, epsilon))) {
				if (row == null) {
					row = i;
				}else {
					return null;
				}
			}
		}
		return row;
	}

	protected void discardArtificialVariables() {
		if ((numArtificialVariables) == 0) {
			return ;
		}
		int width = ((getWidth()) - (numArtificialVariables)) - 1;
		int height = (getHeight()) - 1;
		double[][] matrix = new double[height][width];
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < (width - 1); j++) {
				matrix[i][j] = getEntry((i + 1), (j + 1));
			}
			matrix[i][(width - 1)] = getEntry((i + 1), getRhsOffset());
		}
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(matrix);
		this.numArtificialVariables = 0;
	}

	private void copyArray(final double[] src, final double[] dest, final int destPos) {
		java.lang.System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
	}

	protected org.apache.commons.math.optimization.RealPointValuePair getSolution() {
		double[] coefficients = new double[getOriginalNumDecisionVariables()];
		java.lang.Integer basicRow = getBasicRow(((getNumObjectiveFunctions()) + (getOriginalNumDecisionVariables())));
		double mostNegative = (basicRow == null) ? 0 : getEntry(basicRow, getRhsOffset());
		java.util.Set<java.lang.Integer> basicRows = new java.util.HashSet<java.lang.Integer>();
		for (int i = 0; i < (coefficients.length); i++) {
			basicRow = getBasicRow(((getNumObjectiveFunctions()) + i));
			if (basicRows.contains(basicRow)) {
				coefficients[i] = 0;
			}else {
				basicRows.add(basicRow);
				coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
			}
		}
		return new org.apache.commons.math.optimization.RealPointValuePair(coefficients, f.getValue(coefficients));
	}

	protected void divideRow(final int dividendRow, final double divisor) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(dividendRow, j, ((tableau.getEntry(dividendRow, j)) / divisor));
		}
	}

	protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(minuendRow, j, ((tableau.getEntry(minuendRow, j)) - (multiple * (tableau.getEntry(subtrahendRow, j)))));
		}
	}

	protected final int getWidth() {
		return tableau.getColumnDimension();
	}

	protected final int getHeight() {
		return tableau.getRowDimension();
	}

	protected final double getEntry(final int row, final int column) {
		return tableau.getEntry(row, column);
	}

	protected final void setEntry(final int row, final int column, final double value) {
		tableau.setEntry(row, column, value);
	}

	protected final int getSlackVariableOffset() {
		return (getNumObjectiveFunctions()) + (numDecisionVariables);
	}

	protected final int getArtificialVariableOffset() {
		return ((getNumObjectiveFunctions()) + (numDecisionVariables)) + (numSlackVariables);
	}

	protected final int getRhsOffset() {
		return (getWidth()) - 1;
	}

	protected final int getNumDecisionVariables() {
		return numDecisionVariables;
	}

	protected final int getOriginalNumDecisionVariables() {
		return restrictToNonNegative ? numDecisionVariables : (numDecisionVariables) - 1;
	}

	protected final int getNumSlackVariables() {
		return numSlackVariables;
	}

	protected final int getNumArtificialVariables() {
		return numArtificialVariables;
	}

	protected final double[][] getData() {
		return tableau.getData();
	}

	@java.lang.Override
	public boolean equals(java.lang.Object other) {
		if ((this) == other) {
			return true;
		}
		if (other == null) {
			return false;
		}
		try {
			org.apache.commons.math.optimization.linear.SimplexTableau rhs = ((org.apache.commons.math.optimization.linear.SimplexTableau) (other));
			return ((((((((restrictToNonNegative) == (rhs.restrictToNonNegative)) && ((numDecisionVariables) == (rhs.numDecisionVariables))) && ((numSlackVariables) == (rhs.numSlackVariables))) && ((numArtificialVariables) == (rhs.numArtificialVariables))) && ((epsilon) == (rhs.epsilon))) && (f.equals(rhs.f))) && (constraints.equals(rhs.constraints))) && (tableau.equals(rhs.tableau));
		} catch (java.lang.ClassCastException ex) {
			return false;
		}
	}

	@java.lang.Override
	public int hashCode() {
		return (((((((java.lang.Boolean.valueOf(restrictToNonNegative).hashCode()) ^ (numDecisionVariables)) ^ (numSlackVariables)) ^ (numArtificialVariables)) ^ (java.lang.Double.valueOf(epsilon).hashCode())) ^ (f.hashCode())) ^ (constraints.hashCode())) ^ (tableau.hashCode());
	}

	private void writeObject(java.io.ObjectOutputStream oos) throws java.io.IOException {
		oos.defaultWriteObject();
		org.apache.commons.math.linear.MatrixUtils.serializeRealMatrix(tableau, oos);
	}

	private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException, java.lang.ClassNotFoundException {
		ois.defaultReadObject();
		org.apache.commons.math.linear.MatrixUtils.deserializeRealMatrix(this, "tableau", ois);
	}
}
2019-04-12 12:57:45,074 ERROR main - Undo Error: modified: 
class SimplexTableau implements java.io.Serializable {
	private static final long serialVersionUID = -1369660067587938365L;

	private final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f;

	private final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints;

	private final boolean restrictToNonNegative;

	protected transient org.apache.commons.math.linear.RealMatrix tableau;

	protected final int numDecisionVariables;

	protected final int numSlackVariables;

	protected int numArtificialVariables;

	protected final double epsilon;

	SimplexTableau(final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f, final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints, final org.apache.commons.math.optimization.GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {
		this.f = f;
		this.constraints = constraints;
		this.restrictToNonNegative = restrictToNonNegative;
		this.epsilon = epsilon;
		this.numDecisionVariables = (getNumVariables()) + (restrictToNonNegative ? 0 : 1);
		this.numSlackVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.LEQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.numArtificialVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.EQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(createTableau((goalType == (org.apache.commons.math.optimization.GoalType.MAXIMIZE))));
		initialize();
	}

	protected double[][] createTableau(final boolean maximize) {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> constraints = getNormalizedConstraints();
		int width = ((((numDecisionVariables) + (numSlackVariables)) + (numArtificialVariables)) + (getNumObjectiveFunctions())) + 1;
		int height = (constraints.size()) + (getNumObjectiveFunctions());
		double[][] matrix = new double[height][width];
		if ((getNumObjectiveFunctions()) == 2) {
			matrix[0][0] = -1;
		}
		int zIndex = ((getNumObjectiveFunctions()) == 1) ? 0 : 1;
		matrix[zIndex][zIndex] = (maximize) ? 1 : -1;
		org.apache.commons.math.linear.RealVector objectiveCoefficients = (maximize) ? f.getCoefficients().mapMultiply((-1)) : f.getCoefficients();
		copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
		matrix[zIndex][(width - 1)] = (maximize) ? f.getConstantTerm() : (-1) * (f.getConstantTerm());
		if (!(restrictToNonNegative)) {
			matrix[zIndex][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(objectiveCoefficients);
		}
		int slackVar = 0;
		int artificialVar = 0;
		for (int i = 0; i < (constraints.size()); i++) {
			org.apache.commons.math.optimization.linear.LinearConstraint constraint = constraints.get(i);
			int row = (getNumObjectiveFunctions()) + i;
			copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
			if (!(restrictToNonNegative)) {
				matrix[row][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(constraint.getCoefficients());
			}
			matrix[row][(width - 1)] = constraint.getValue();
			if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.LEQ)) {
				matrix[row][((getSlackVariableOffset()) + (slackVar++))] = 1;
			}else
				if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ)) {
					matrix[row][((getSlackVariableOffset()) + (slackVar++))] = -1;
				}
			
			if (((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.EQ)) || ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ))) {
				matrix[0][((getArtificialVariableOffset()) + artificialVar)] = 1;
				matrix[row][((getArtificialVariableOffset()) + (artificialVar++))] = 1;
			}
		}
		return matrix;
	}

	public int getNumVariables() {
		return f.getCoefficients().getDimension();
	}

	public java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> getNormalizedConstraints() {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> normalized = new java.util.ArrayList<org.apache.commons.math.optimization.linear.LinearConstraint>();
		for (org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			normalized.add(normalize(constraint));
		}
		return normalized;
	}

	private org.apache.commons.math.optimization.linear.LinearConstraint normalize(final org.apache.commons.math.optimization.linear.LinearConstraint constraint) {
		if ((constraint.getValue()) < 0) {
			return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients().mapMultiply((-1)), constraint.getRelationship().oppositeRelationship(), ((-1) * (constraint.getValue())));
		}
		return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());
	}

	protected final int getNumObjectiveFunctions() {
		return (this.numArtificialVariables) > 0 ? 2 : 1;
	}

	private int getConstraintTypeCounts(final org.apache.commons.math.optimization.linear.Relationship relationship) {
		int count = 0;
		for (final org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			if ((constraint.getRelationship()) == relationship) {
				++count;
			}
		}
		return count;
	}

	private void initialize() {
		for (int artificialVar = 0; artificialVar < (numArtificialVariables); artificialVar++) {
			int row = getBasicRow(((getArtificialVariableOffset()) + artificialVar));
			subtractRow(0, row, 1.0);
		}
	}

	protected static double getInvertedCoeffiecientSum(final org.apache.commons.math.linear.RealVector coefficients) {
		double sum = 0;
		for (double coefficient : coefficients.getData()) {
			sum -= coefficient;
		}
		return sum;
	}

	private java.lang.Integer getBasicRow(final int col) {
		java.lang.Integer row = null;
		for (int i = getNumObjectiveFunctions(); i < (getHeight()); i++) {
			if (!(org.apache.commons.math.util.MathUtils.equals(getEntry(i, col), 0.0, epsilon))) {
				if (row == null) {
					row = i;
				}else {
					return null;
				}
			}
		}
		return row;
	}

	protected void discardArtificialVariables() {
		if ((numArtificialVariables) == 0)
			return ;
		
		int width = ((getWidth()) - (numArtificialVariables)) - 1;
		int height = (getHeight()) - 1;
		double[][] matrix = new double[height][width];
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < (width - 1); j++) {
				matrix[i][j] = getEntry((i + 1), (j + 1));
			}
			matrix[i][(width - 1)] = getEntry((i + 1), getRhsOffset());
		}
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(matrix);
		this.numArtificialVariables = 0;
	}

	private void copyArray(final double[] src, final double[] dest, final int destPos) {
		java.lang.System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
	}

	protected org.apache.commons.math.optimization.RealPointValuePair getSolution() {
		double[] coefficients = new double[getOriginalNumDecisionVariables()];
		java.lang.Integer basicRow = getBasicRow(((getNumObjectiveFunctions()) + (getOriginalNumDecisionVariables())));
		double mostNegative = (basicRow == null) ? 0 : getEntry(basicRow, getRhsOffset());
		java.util.Set<java.lang.Integer> basicRows = new java.util.HashSet<java.lang.Integer>();
		for (int i = 0; i < (coefficients.length); i++) {
			basicRow = getBasicRow(((getNumObjectiveFunctions()) + i));
			if (basicRows.contains(basicRow)) {
				coefficients[i] = 0;
			}else {
				basicRows.add(basicRow);
				coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
			}
		}
		return new org.apache.commons.math.optimization.RealPointValuePair(coefficients, f.getValue(coefficients));
	}

	protected void divideRow(final int dividendRow, final double divisor) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(dividendRow, j, ((tableau.getEntry(dividendRow, j)) / divisor));
		}
	}

	protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(minuendRow, j, ((tableau.getEntry(minuendRow, j)) - (multiple * (tableau.getEntry(subtrahendRow, j)))));
		}
	}

	protected final int getWidth() {
		return tableau.getColumnDimension();
	}

	protected final int getHeight() {
		return tableau.getRowDimension();
	}

	protected final double getEntry(final int row, final int column) {
		return tableau.getEntry(row, column);
	}

	protected final void setEntry(final int row, final int column, final double value) {
		tableau.setEntry(row, column, value);
	}

	protected final int getSlackVariableOffset() {
		return (getNumObjectiveFunctions()) + (numDecisionVariables);
	}

	protected final int getArtificialVariableOffset() {
		return ((getNumObjectiveFunctions()) + (numDecisionVariables)) + (numSlackVariables);
	}

	protected final int getRhsOffset() {
		return (getWidth()) - 1;
	}

	protected final int getNumDecisionVariables() {
		return numDecisionVariables;
	}

	protected final int getOriginalNumDecisionVariables() {
		return restrictToNonNegative ? numDecisionVariables : (numDecisionVariables) - 1;
	}

	protected final int getNumSlackVariables() {
		return numSlackVariables;
	}

	protected final int getNumArtificialVariables() {
		return numArtificialVariables;
	}

	protected final double[][] getData() {
		return tableau.getData();
	}

	@java.lang.Override
	public boolean equals(java.lang.Object other) {
		if ((this) == other) {
			return true;
		}
		if (other == null) {
			return false;
		}
		try {
			org.apache.commons.math.optimization.linear.SimplexTableau rhs = ((org.apache.commons.math.optimization.linear.SimplexTableau) (other));
			return ((((((((restrictToNonNegative) == (rhs.restrictToNonNegative)) && ((numDecisionVariables) == (rhs.numDecisionVariables))) && ((numSlackVariables) == (rhs.numSlackVariables))) && ((numArtificialVariables) == (rhs.numArtificialVariables))) && ((epsilon) == (rhs.epsilon))) && (f.equals(rhs.f))) && (constraints.equals(rhs.constraints))) && (tableau.equals(rhs.tableau));
		} catch (java.lang.ClassCastException ex) {
			return false;
		}
	}

	@java.lang.Override
	public int hashCode() {
		return (((((((java.lang.Boolean.valueOf(restrictToNonNegative).hashCode()) ^ (numDecisionVariables)) ^ (numSlackVariables)) ^ (numArtificialVariables)) ^ (java.lang.Double.valueOf(epsilon).hashCode())) ^ (f.hashCode())) ^ (constraints.hashCode())) ^ (tableau.hashCode());
	}

	private void writeObject(java.io.ObjectOutputStream oos) throws java.io.IOException {
		oos.defaultWriteObject();
		org.apache.commons.math.linear.MatrixUtils.serializeRealMatrix(tableau, oos);
	}

	private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException, java.lang.ClassNotFoundException {
		ois.defaultReadObject();
		org.apache.commons.math.linear.MatrixUtils.deserializeRealMatrix(this, "tableau", ois);
	}
}
2019-04-12 12:57:46,494 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:57:46,494 ERROR main - Undo Error: original: 
class SimplexTableau implements java.io.Serializable {
	private static final long serialVersionUID = -1369660067587938365L;

	private final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f;

	private final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints;

	private final boolean restrictToNonNegative;

	protected transient org.apache.commons.math.linear.RealMatrix tableau;

	protected final int numDecisionVariables;

	protected final int numSlackVariables;

	protected int numArtificialVariables;

	protected final double epsilon;

	SimplexTableau(final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f, final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints, final org.apache.commons.math.optimization.GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {
		this.f = f;
		this.constraints = constraints;
		this.restrictToNonNegative = restrictToNonNegative;
		this.epsilon = epsilon;
		this.numDecisionVariables = (getNumVariables()) + (restrictToNonNegative ? 0 : 1);
		this.numSlackVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.LEQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.numArtificialVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.EQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(createTableau((goalType == (org.apache.commons.math.optimization.GoalType.MAXIMIZE))));
		initialize();
	}

	protected double[][] createTableau(final boolean maximize) {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> constraints = getNormalizedConstraints();
		int width = ((((numDecisionVariables) + (numSlackVariables)) + (numArtificialVariables)) + (getNumObjectiveFunctions())) + 1;
		int height = (constraints.size()) + (getNumObjectiveFunctions());
		double[][] matrix = new double[height][width];
		if ((getNumObjectiveFunctions()) == 2) {
			matrix[0][0] = -1;
		}
		int zIndex = ((getNumObjectiveFunctions()) == 1) ? 0 : 1;
		matrix[zIndex][zIndex] = (maximize) ? 1 : -1;
		org.apache.commons.math.linear.RealVector objectiveCoefficients = (maximize) ? f.getCoefficients().mapMultiply((-1)) : f.getCoefficients();
		copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
		matrix[zIndex][(width - 1)] = (maximize) ? f.getConstantTerm() : (-1) * (f.getConstantTerm());
		if (!(restrictToNonNegative)) {
			matrix[zIndex][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(objectiveCoefficients);
		}
		int slackVar = 0;
		int artificialVar = 0;
		for (int i = 0; i < (constraints.size()); i++) {
			org.apache.commons.math.optimization.linear.LinearConstraint constraint = constraints.get(i);
			int row = (getNumObjectiveFunctions()) + i;
			copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
			if (!(restrictToNonNegative)) {
				matrix[row][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(constraint.getCoefficients());
			}
			matrix[row][(width - 1)] = constraint.getValue();
			if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.LEQ)) {
				matrix[row][((getSlackVariableOffset()) + (slackVar++))] = 1;
			}else
				if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ)) {
					matrix[row][((getSlackVariableOffset()) + (slackVar++))] = -1;
				}
			
			if (((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.EQ)) || ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ))) {
				matrix[0][((getArtificialVariableOffset()) + artificialVar)] = 1;
				matrix[row][((getArtificialVariableOffset()) + (artificialVar++))] = 1;
			}
		}
		return matrix;
	}

	public int getNumVariables() {
		return f.getCoefficients().getDimension();
	}

	public java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> getNormalizedConstraints() {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> normalized = new java.util.ArrayList<org.apache.commons.math.optimization.linear.LinearConstraint>();
		for (org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			normalized.add(normalize(constraint));
		}
		return normalized;
	}

	private org.apache.commons.math.optimization.linear.LinearConstraint normalize(final org.apache.commons.math.optimization.linear.LinearConstraint constraint) {
		if ((constraint.getValue()) < 0) {
			return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients().mapMultiply((-1)), constraint.getRelationship().oppositeRelationship(), ((-1) * (constraint.getValue())));
		}
		return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());
	}

	protected final int getNumObjectiveFunctions() {
		return (this.numArtificialVariables) > 0 ? 2 : 1;
	}

	private int getConstraintTypeCounts(final org.apache.commons.math.optimization.linear.Relationship relationship) {
		int count = 0;
		for (final org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			if ((constraint.getRelationship()) == relationship) {
				++count;
			}
		}
		return count;
	}

	private void initialize() {
		for (int artificialVar = 0; artificialVar < (numArtificialVariables); artificialVar++) {
			int row = getBasicRow(((getArtificialVariableOffset()) + artificialVar));
			subtractRow(0, row, 1.0);
		}
	}

	protected static double getInvertedCoeffiecientSum(final org.apache.commons.math.linear.RealVector coefficients) {
		double sum = 0;
		for (double coefficient : coefficients.getData()) {
			sum -= coefficient;
		}
		return sum;
	}

	private java.lang.Integer getBasicRow(final int col) {
		java.lang.Integer row = null;
		for (int i = getNumObjectiveFunctions(); i < (getHeight()); i++) {
			if (!(org.apache.commons.math.util.MathUtils.equals(getEntry(i, col), 0.0, epsilon))) {
				if (row == null) {
					row = i;
				}else {
					return null;
				}
			}
		}
		return row;
	}

	protected void discardArtificialVariables() {
		if ((numArtificialVariables) == 0) {
			return ;
		}
		int width = ((getWidth()) - (numArtificialVariables)) - 1;
		int height = (getHeight()) - 1;
		double[][] matrix = new double[height][width];
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < (width - 1); j++) {
				matrix[i][j] = getEntry((i + 1), (j + 1));
			}
			matrix[i][(width - 1)] = getEntry((i + 1), getRhsOffset());
		}
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(matrix);
		this.numArtificialVariables = 0;
	}

	private void copyArray(final double[] src, final double[] dest, final int destPos) {
		java.lang.System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
	}

	protected org.apache.commons.math.optimization.RealPointValuePair getSolution() {
		double[] coefficients = new double[getOriginalNumDecisionVariables()];
		java.lang.Integer basicRow = getBasicRow(((getNumObjectiveFunctions()) + (getOriginalNumDecisionVariables())));
		double mostNegative = (basicRow == null) ? 0 : getEntry(basicRow, getRhsOffset());
		java.util.Set<java.lang.Integer> basicRows = new java.util.HashSet<java.lang.Integer>();
		for (int i = 0; i < (coefficients.length); i++) {
			basicRow = getBasicRow(((getNumObjectiveFunctions()) + i));
			if (basicRows.contains(basicRow)) {
				coefficients[i] = 0;
			}else {
				basicRows.add(basicRow);
				coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
			}
		}
		return new org.apache.commons.math.optimization.RealPointValuePair(coefficients, f.getValue(coefficients));
	}

	protected void divideRow(final int dividendRow, final double divisor) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(dividendRow, j, ((tableau.getEntry(dividendRow, j)) / divisor));
		}
	}

	protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(minuendRow, j, ((tableau.getEntry(minuendRow, j)) - (multiple * (tableau.getEntry(subtrahendRow, j)))));
		}
	}

	protected final int getWidth() {
		return tableau.getColumnDimension();
	}

	protected final int getHeight() {
		return tableau.getRowDimension();
	}

	protected final double getEntry(final int row, final int column) {
		return tableau.getEntry(row, column);
	}

	protected final void setEntry(final int row, final int column, final double value) {
		tableau.setEntry(row, column, value);
	}

	protected final int getSlackVariableOffset() {
		return (getNumObjectiveFunctions()) + (numDecisionVariables);
	}

	protected final int getArtificialVariableOffset() {
		return ((getNumObjectiveFunctions()) + (numDecisionVariables)) + (numSlackVariables);
	}

	protected final int getRhsOffset() {
		return (getWidth()) - 1;
	}

	protected final int getNumDecisionVariables() {
		return numDecisionVariables;
	}

	protected final int getOriginalNumDecisionVariables() {
		return restrictToNonNegative ? numDecisionVariables : (numDecisionVariables) - 1;
	}

	protected final int getNumSlackVariables() {
		return numSlackVariables;
	}

	protected final int getNumArtificialVariables() {
		return numArtificialVariables;
	}

	protected final double[][] getData() {
		return tableau.getData();
	}

	@java.lang.Override
	public boolean equals(java.lang.Object other) {
		if ((this) == other) {
			return true;
		}
		if (other == null) {
			return false;
		}
		try {
			org.apache.commons.math.optimization.linear.SimplexTableau rhs = ((org.apache.commons.math.optimization.linear.SimplexTableau) (other));
			return ((((((((restrictToNonNegative) == (rhs.restrictToNonNegative)) && ((numDecisionVariables) == (rhs.numDecisionVariables))) && ((numSlackVariables) == (rhs.numSlackVariables))) && ((numArtificialVariables) == (rhs.numArtificialVariables))) && ((epsilon) == (rhs.epsilon))) && (f.equals(rhs.f))) && (constraints.equals(rhs.constraints))) && (tableau.equals(rhs.tableau));
		} catch (java.lang.ClassCastException ex) {
			return false;
		}
	}

	@java.lang.Override
	public int hashCode() {
		return (((((((java.lang.Boolean.valueOf(restrictToNonNegative).hashCode()) ^ (numDecisionVariables)) ^ (numSlackVariables)) ^ (numArtificialVariables)) ^ (java.lang.Double.valueOf(epsilon).hashCode())) ^ (f.hashCode())) ^ (constraints.hashCode())) ^ (tableau.hashCode());
	}

	private void writeObject(java.io.ObjectOutputStream oos) throws java.io.IOException {
		oos.defaultWriteObject();
		org.apache.commons.math.linear.MatrixUtils.serializeRealMatrix(tableau, oos);
	}

	private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException, java.lang.ClassNotFoundException {
		ois.defaultReadObject();
		org.apache.commons.math.linear.MatrixUtils.deserializeRealMatrix(this, "tableau", ois);
	}
}
2019-04-12 12:57:46,497 ERROR main - Undo Error: modified: 
class SimplexTableau implements java.io.Serializable {
	private static final long serialVersionUID = -1369660067587938365L;

	private final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f;

	private final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints;

	private final boolean restrictToNonNegative;

	protected transient org.apache.commons.math.linear.RealMatrix tableau;

	protected final int numDecisionVariables;

	protected final int numSlackVariables;

	protected int numArtificialVariables;

	protected final double epsilon;

	SimplexTableau(final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f, final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints, final org.apache.commons.math.optimization.GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {
		this.f = f;
		this.constraints = constraints;
		this.restrictToNonNegative = restrictToNonNegative;
		this.epsilon = epsilon;
		this.numDecisionVariables = (getNumVariables()) + (restrictToNonNegative ? 0 : 1);
		this.numSlackVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.LEQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.numArtificialVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.EQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(createTableau((goalType == (org.apache.commons.math.optimization.GoalType.MAXIMIZE))));
		initialize();
	}

	protected double[][] createTableau(final boolean maximize) {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> constraints = getNormalizedConstraints();
		int width = ((((numDecisionVariables) + (numSlackVariables)) + (numArtificialVariables)) + (getNumObjectiveFunctions())) + 1;
		int height = (constraints.size()) + (getNumObjectiveFunctions());
		double[][] matrix = new double[height][width];
		if ((getNumObjectiveFunctions()) == 2) {
			matrix[0][0] = -1;
		}
		int zIndex = ((getNumObjectiveFunctions()) == 1) ? 0 : 1;
		matrix[zIndex][zIndex] = (maximize) ? 1 : -1;
		org.apache.commons.math.linear.RealVector objectiveCoefficients = (maximize) ? f.getCoefficients().mapMultiply((-1)) : f.getCoefficients();
		copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
		matrix[zIndex][(width - 1)] = (maximize) ? f.getConstantTerm() : (-1) * (f.getConstantTerm());
		if (!(restrictToNonNegative)) {
			matrix[zIndex][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(objectiveCoefficients);
		}
		int slackVar = 0;
		int artificialVar = 0;
		for (int i = 0; i < (constraints.size()); i++) {
			org.apache.commons.math.optimization.linear.LinearConstraint constraint = constraints.get(i);
			int row = (getNumObjectiveFunctions()) + i;
			copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
			if (!(restrictToNonNegative)) {
				matrix[row][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(constraint.getCoefficients());
			}
			matrix[row][(width - 1)] = constraint.getValue();
			if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.LEQ)) {
				matrix[row][((getSlackVariableOffset()) + (slackVar++))] = 1;
			}else
				if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ)) {
					matrix[row][((getSlackVariableOffset()) + (slackVar++))] = -1;
				}
			
			if (((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.EQ)) || ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ))) {
				matrix[0][((getArtificialVariableOffset()) + artificialVar)] = 1;
				matrix[row][((getArtificialVariableOffset()) + (artificialVar++))] = 1;
			}
		}
		return matrix;
	}

	public int getNumVariables() {
		return f.getCoefficients().getDimension();
	}

	public java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> getNormalizedConstraints() {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> normalized = new java.util.ArrayList<org.apache.commons.math.optimization.linear.LinearConstraint>();
		for (org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			normalized.add(normalize(constraint));
		}
		return normalized;
	}

	private org.apache.commons.math.optimization.linear.LinearConstraint normalize(final org.apache.commons.math.optimization.linear.LinearConstraint constraint) {
		if ((constraint.getValue()) < 0) {
			return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients().mapMultiply((-1)), constraint.getRelationship().oppositeRelationship(), ((-1) * (constraint.getValue())));
		}
		return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());
	}

	protected final int getNumObjectiveFunctions() {
		return (this.numArtificialVariables) > 0 ? 2 : 1;
	}

	private int getConstraintTypeCounts(final org.apache.commons.math.optimization.linear.Relationship relationship) {
		int count = 0;
		for (final org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			if ((constraint.getRelationship()) == relationship) {
				++count;
			}
		}
		return count;
	}

	private void initialize() {
		for (int artificialVar = 0; artificialVar < (numArtificialVariables); artificialVar++) {
			int row = getBasicRow(((getArtificialVariableOffset()) + artificialVar));
			subtractRow(0, row, 1.0);
		}
	}

	protected static double getInvertedCoeffiecientSum(final org.apache.commons.math.linear.RealVector coefficients) {
		double sum = 0;
		for (double coefficient : coefficients.getData()) {
			sum -= coefficient;
		}
		return sum;
	}

	private java.lang.Integer getBasicRow(final int col) {
		java.lang.Integer row = null;
		for (int i = getNumObjectiveFunctions(); i < (getHeight()); i++) {
			if (!(org.apache.commons.math.util.MathUtils.equals(getEntry(i, col), 0.0, epsilon))) {
				if (row == null) {
					row = i;
				}else {
					return null;
				}
			}
		}
		return row;
	}

	protected void discardArtificialVariables() {
		if ((numArtificialVariables) == 0)
			return ;
		
		int width = ((getWidth()) - (numArtificialVariables)) - 1;
		int height = (getHeight()) - 1;
		double[][] matrix = new double[height][width];
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < (width - 1); j++) {
				matrix[i][j] = getEntry((i + 1), (j + 1));
			}
			matrix[i][(width - 1)] = getEntry((i + 1), getRhsOffset());
		}
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(matrix);
		this.numArtificialVariables = 0;
	}

	private void copyArray(final double[] src, final double[] dest, final int destPos) {
		java.lang.System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
	}

	protected org.apache.commons.math.optimization.RealPointValuePair getSolution() {
		double[] coefficients = new double[getOriginalNumDecisionVariables()];
		java.lang.Integer basicRow = getBasicRow(((getNumObjectiveFunctions()) + (getOriginalNumDecisionVariables())));
		double mostNegative = (basicRow == null) ? 0 : getEntry(basicRow, getRhsOffset());
		java.util.Set<java.lang.Integer> basicRows = new java.util.HashSet<java.lang.Integer>();
		for (int i = 0; i < (coefficients.length); i++) {
			basicRow = getBasicRow(((getNumObjectiveFunctions()) + i));
			if (basicRows.contains(basicRow)) {
				coefficients[i] = 0;
			}else {
				basicRows.add(basicRow);
				coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
			}
		}
		return new org.apache.commons.math.optimization.RealPointValuePair(coefficients, f.getValue(coefficients));
	}

	protected void divideRow(final int dividendRow, final double divisor) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(dividendRow, j, ((tableau.getEntry(dividendRow, j)) / divisor));
		}
	}

	protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(minuendRow, j, ((tableau.getEntry(minuendRow, j)) - (multiple * (tableau.getEntry(subtrahendRow, j)))));
		}
	}

	protected final int getWidth() {
		return tableau.getColumnDimension();
	}

	protected final int getHeight() {
		return tableau.getRowDimension();
	}

	protected final double getEntry(final int row, final int column) {
		return tableau.getEntry(row, column);
	}

	protected final void setEntry(final int row, final int column, final double value) {
		tableau.setEntry(row, column, value);
	}

	protected final int getSlackVariableOffset() {
		return (getNumObjectiveFunctions()) + (numDecisionVariables);
	}

	protected final int getArtificialVariableOffset() {
		return ((getNumObjectiveFunctions()) + (numDecisionVariables)) + (numSlackVariables);
	}

	protected final int getRhsOffset() {
		return (getWidth()) - 1;
	}

	protected final int getNumDecisionVariables() {
		return numDecisionVariables;
	}

	protected final int getOriginalNumDecisionVariables() {
		return restrictToNonNegative ? numDecisionVariables : (numDecisionVariables) - 1;
	}

	protected final int getNumSlackVariables() {
		return numSlackVariables;
	}

	protected final int getNumArtificialVariables() {
		return numArtificialVariables;
	}

	protected final double[][] getData() {
		return tableau.getData();
	}

	@java.lang.Override
	public boolean equals(java.lang.Object other) {
		if ((this) == other) {
			return true;
		}
		if (other == null) {
			return false;
		}
		try {
			org.apache.commons.math.optimization.linear.SimplexTableau rhs = ((org.apache.commons.math.optimization.linear.SimplexTableau) (other));
			return ((((((((restrictToNonNegative) == (rhs.restrictToNonNegative)) && ((numDecisionVariables) == (rhs.numDecisionVariables))) && ((numSlackVariables) == (rhs.numSlackVariables))) && ((numArtificialVariables) == (rhs.numArtificialVariables))) && ((epsilon) == (rhs.epsilon))) && (f.equals(rhs.f))) && (constraints.equals(rhs.constraints))) && (tableau.equals(rhs.tableau));
		} catch (java.lang.ClassCastException ex) {
			return false;
		}
	}

	@java.lang.Override
	public int hashCode() {
		return (((((((java.lang.Boolean.valueOf(restrictToNonNegative).hashCode()) ^ (numDecisionVariables)) ^ (numSlackVariables)) ^ (numArtificialVariables)) ^ (java.lang.Double.valueOf(epsilon).hashCode())) ^ (f.hashCode())) ^ (constraints.hashCode())) ^ (tableau.hashCode());
	}

	private void writeObject(java.io.ObjectOutputStream oos) throws java.io.IOException {
		oos.defaultWriteObject();
		org.apache.commons.math.linear.MatrixUtils.serializeRealMatrix(tableau, oos);
	}

	private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException, java.lang.ClassNotFoundException {
		ois.defaultReadObject();
		org.apache.commons.math.linear.MatrixUtils.deserializeRealMatrix(this, "tableau", ois);
	}
}
2019-04-12 12:57:48,581 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:57:48,581 ERROR main - Undo Error: original: 
public class SimplexSolver extends org.apache.commons.math.optimization.linear.AbstractLinearOptimizer {
	private static final double DEFAULT_EPSILON = 1.0E-6;

	protected final double epsilon;

	public SimplexSolver() {
		this(org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON);
	}

	public SimplexSolver(final double epsilon) {
		this.epsilon = epsilon;
	}

	private java.lang.Integer getPivotColumn(org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minValue = 0;
		java.lang.Integer minPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon)) < 0) {
				minValue = tableau.getEntry(0, i);
				minPos = i;
			}
		}
		return minPos;
	}

	private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minRatio = java.lang.Double.MAX_VALUE;
		java.lang.Integer minRatioPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < (tableau.getHeight()); i++) {
			double rhs = tableau.getEntry(i, ((tableau.getWidth()) - 1));
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon)) >= 0) {
				double ratio = rhs / (tableau.getEntry(i, col));
				if (ratio < minRatio) {
					minRatio = ratio;
					minRatioPos = i;
				}
			}
		}
		return minRatioPos;
	}

	protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		incrementIterationsCounter();
		java.lang.Integer pivotCol = getPivotColumn(tableau);
		java.lang.Integer pivotRow = getPivotRow(pivotCol, tableau);
		if (pivotRow == null) {
			throw new org.apache.commons.math.optimization.linear.UnboundedSolutionException();
		}
		double pivotVal = tableau.getEntry(pivotRow, pivotCol);
		tableau.divideRow(pivotRow, pivotVal);
		for (int i = 0; i < (tableau.getHeight()); i++) {
			if (i != pivotRow) {
				double multiplier = tableau.getEntry(i, pivotCol);
				tableau.subtractRow(i, pivotRow, multiplier);
			}
		}
	}

	private boolean isPhase1Solved(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) == 0) {
			return true;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	public boolean isOptimal(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) > 0) {
			return false;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	protected void solvePhase1(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		if ((tableau.getNumArtificialVariables()) == 0) {
			return ;
		}
		while (!(isPhase1Solved(tableau))) {
			doIteration(tableau);
		} 
		if (!(org.apache.commons.math.util.MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon))) {
			throw new org.apache.commons.math.optimization.linear.NoFeasibleSolutionException();
		}
	}

	@java.lang.Override
	public org.apache.commons.math.optimization.RealPointValuePair doOptimize() throws org.apache.commons.math.optimization.OptimizationException {
		final org.apache.commons.math.optimization.linear.SimplexTableau tableau = new org.apache.commons.math.optimization.linear.SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);
		solvePhase1(tableau);
		tableau.discardArtificialVariables();
		while (!(isOptimal(tableau))) {
			doIteration(tableau);
		} 
		return tableau.getSolution();
	}
}
2019-04-12 12:57:48,582 ERROR main - Undo Error: modified: 
public class SimplexSolver extends org.apache.commons.math.optimization.linear.AbstractLinearOptimizer {
	private static final double DEFAULT_EPSILON = 1.0E-6;

	protected final double epsilon;

	public SimplexSolver() {
		this(org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON);
	}

	public SimplexSolver(final double epsilon) {
		this.epsilon = epsilon;
	}

	private java.lang.Integer getPivotColumn(org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minValue = 0;
		java.lang.Integer minPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon)) < 0) {
				minValue = tableau.getEntry(0, i);
				minPos = i;
			}
		}
		return minPos;
	}

	private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minRatio = java.lang.Double.MAX_VALUE;
		java.lang.Integer minRatioPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < (tableau.getHeight()); i++) {
			double rhs = tableau.getEntry(i, ((tableau.getWidth()) - 1));
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon)) >= 0) {
				double ratio = rhs / (tableau.getEntry(i, col));
				if (ratio < minRatio) {
					minRatio = ratio;
					minRatioPos = i;
				}
			}
		}
		return minRatioPos;
	}

	protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		incrementIterationsCounter();
		java.lang.Integer pivotCol = getPivotColumn(tableau);
		java.lang.Integer pivotRow = getPivotRow(pivotCol, tableau);
		if (pivotRow == null) {
			throw new org.apache.commons.math.optimization.linear.UnboundedSolutionException();
		}
		double pivotVal = tableau.getEntry(pivotRow, pivotCol);
		tableau.divideRow(pivotRow, pivotVal);
		for (int i = 0; i < (tableau.getHeight()); i++) {
			if (i != pivotRow) {
				double multiplier = tableau.getEntry(i, pivotCol);
				tableau.subtractRow(i, pivotRow, multiplier);
			}
		}
	}

	private boolean isPhase1Solved(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) == 0) {
			return true;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	public boolean isOptimal(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) > 0) {
			return false;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	protected void solvePhase1(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		if ((tableau.getNumArtificialVariables()) == 0)
			return ;
		
		while (!(isPhase1Solved(tableau))) {
			doIteration(tableau);
		} 
		if (!(org.apache.commons.math.util.MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon))) {
			throw new org.apache.commons.math.optimization.linear.NoFeasibleSolutionException();
		}
	}

	@java.lang.Override
	public org.apache.commons.math.optimization.RealPointValuePair doOptimize() throws org.apache.commons.math.optimization.OptimizationException {
		final org.apache.commons.math.optimization.linear.SimplexTableau tableau = new org.apache.commons.math.optimization.linear.SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);
		solvePhase1(tableau);
		tableau.discardArtificialVariables();
		while (!(isOptimal(tableau))) {
			doIteration(tableau);
		} 
		return tableau.getSolution();
	}
}
2019-04-12 12:57:50,430 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:57:50,431 ERROR main - Undo Error: original: 
public class SimplexSolver extends org.apache.commons.math.optimization.linear.AbstractLinearOptimizer {
	private static final double DEFAULT_EPSILON = 1.0E-6;

	protected final double epsilon;

	public SimplexSolver() {
		this(org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON);
	}

	public SimplexSolver(final double epsilon) {
		this.epsilon = epsilon;
	}

	private java.lang.Integer getPivotColumn(org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minValue = 0;
		java.lang.Integer minPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon)) < 0) {
				minValue = tableau.getEntry(0, i);
				minPos = i;
			}
		}
		return minPos;
	}

	private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minRatio = java.lang.Double.MAX_VALUE;
		java.lang.Integer minRatioPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < (tableau.getHeight()); i++) {
			double rhs = tableau.getEntry(i, ((tableau.getWidth()) - 1));
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon)) >= 0) {
				double ratio = rhs / (tableau.getEntry(i, col));
				if (ratio < minRatio) {
					minRatio = ratio;
					minRatioPos = i;
				}
			}
		}
		return minRatioPos;
	}

	protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		incrementIterationsCounter();
		java.lang.Integer pivotCol = getPivotColumn(tableau);
		java.lang.Integer pivotRow = getPivotRow(pivotCol, tableau);
		if (pivotRow == null) {
			throw new org.apache.commons.math.optimization.linear.UnboundedSolutionException();
		}
		double pivotVal = tableau.getEntry(pivotRow, pivotCol);
		tableau.divideRow(pivotRow, pivotVal);
		for (int i = 0; i < (tableau.getHeight()); i++) {
			if (i != pivotRow) {
				double multiplier = tableau.getEntry(i, pivotCol);
				tableau.subtractRow(i, pivotRow, multiplier);
			}
		}
	}

	private boolean isPhase1Solved(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) == 0) {
			return true;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	public boolean isOptimal(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) > 0) {
			return false;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	protected void solvePhase1(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		if ((tableau.getNumArtificialVariables()) == 0) {
			return ;
		}
		while (!(isPhase1Solved(tableau))) {
			doIteration(tableau);
		} 
		if (!(org.apache.commons.math.util.MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon))) {
			throw new org.apache.commons.math.optimization.linear.NoFeasibleSolutionException();
		}
	}

	@java.lang.Override
	public org.apache.commons.math.optimization.RealPointValuePair doOptimize() throws org.apache.commons.math.optimization.OptimizationException {
		final org.apache.commons.math.optimization.linear.SimplexTableau tableau = new org.apache.commons.math.optimization.linear.SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);
		solvePhase1(tableau);
		tableau.discardArtificialVariables();
		while (!(isOptimal(tableau))) {
			doIteration(tableau);
		} 
		return tableau.getSolution();
	}
}
2019-04-12 12:57:50,431 ERROR main - Undo Error: modified: 
public class SimplexSolver extends org.apache.commons.math.optimization.linear.AbstractLinearOptimizer {
	private static final double DEFAULT_EPSILON = 1.0E-6;

	protected final double epsilon;

	public SimplexSolver() {
		this(org.apache.commons.math.optimization.linear.SimplexSolver.DEFAULT_EPSILON);
	}

	public SimplexSolver(final double epsilon) {
		this.epsilon = epsilon;
	}

	private java.lang.Integer getPivotColumn(org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minValue = 0;
		java.lang.Integer minPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), minValue, epsilon)) < 0) {
				minValue = tableau.getEntry(0, i);
				minPos = i;
			}
		}
		return minPos;
	}

	private java.lang.Integer getPivotRow(final int col, final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		double minRatio = java.lang.Double.MAX_VALUE;
		java.lang.Integer minRatioPos = null;
		for (int i = tableau.getNumObjectiveFunctions(); i < (tableau.getHeight()); i++) {
			double rhs = tableau.getEntry(i, ((tableau.getWidth()) - 1));
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(i, col), 0, epsilon)) >= 0) {
				double ratio = rhs / (tableau.getEntry(i, col));
				if (ratio < minRatio) {
					minRatio = ratio;
					minRatioPos = i;
				}
			}
		}
		return minRatioPos;
	}

	protected void doIteration(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		incrementIterationsCounter();
		java.lang.Integer pivotCol = getPivotColumn(tableau);
		java.lang.Integer pivotRow = getPivotRow(pivotCol, tableau);
		if (pivotRow == null) {
			throw new org.apache.commons.math.optimization.linear.UnboundedSolutionException();
		}
		double pivotVal = tableau.getEntry(pivotRow, pivotCol);
		tableau.divideRow(pivotRow, pivotVal);
		for (int i = 0; i < (tableau.getHeight()); i++) {
			if (i != pivotRow) {
				double multiplier = tableau.getEntry(i, pivotCol);
				tableau.subtractRow(i, pivotRow, multiplier);
			}
		}
	}

	private boolean isPhase1Solved(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) == 0) {
			return true;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	public boolean isOptimal(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) {
		if ((tableau.getNumArtificialVariables()) > 0) {
			return false;
		}
		for (int i = tableau.getNumObjectiveFunctions(); i < ((tableau.getWidth()) - 1); i++) {
			if ((org.apache.commons.math.util.MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon)) < 0) {
				return false;
			}
		}
		return true;
	}

	protected void solvePhase1(final org.apache.commons.math.optimization.linear.SimplexTableau tableau) throws org.apache.commons.math.optimization.OptimizationException {
		if ((tableau.getNumArtificialVariables()) == 0)
			return ;
		
		while (!(isPhase1Solved(tableau))) {
			doIteration(tableau);
		} 
		if (!(org.apache.commons.math.util.MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon))) {
			throw new org.apache.commons.math.optimization.linear.NoFeasibleSolutionException();
		}
	}

	@java.lang.Override
	public org.apache.commons.math.optimization.RealPointValuePair doOptimize() throws org.apache.commons.math.optimization.OptimizationException {
		final org.apache.commons.math.optimization.linear.SimplexTableau tableau = new org.apache.commons.math.optimization.linear.SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);
		solvePhase1(tableau);
		tableau.discardArtificialVariables();
		while (!(isOptimal(tableau))) {
			doIteration(tableau);
		} 
		return tableau.getSolution();
	}
}
2019-04-12 12:57:56,151 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 12:57:56,151 ERROR main - Undo Error: original: 
class SimplexTableau implements java.io.Serializable {
	private static final long serialVersionUID = -1369660067587938365L;

	private final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f;

	private final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints;

	private final boolean restrictToNonNegative;

	protected transient org.apache.commons.math.linear.RealMatrix tableau;

	protected final int numDecisionVariables;

	protected final int numSlackVariables;

	protected int numArtificialVariables;

	protected final double epsilon;

	SimplexTableau(final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f, final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints, final org.apache.commons.math.optimization.GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {
		this.f = f;
		this.constraints = constraints;
		this.restrictToNonNegative = restrictToNonNegative;
		this.epsilon = epsilon;
		this.numDecisionVariables = (getNumVariables()) + (restrictToNonNegative ? 0 : 1);
		this.numSlackVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.LEQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.numArtificialVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.EQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(createTableau((goalType == (org.apache.commons.math.optimization.GoalType.MAXIMIZE))));
		initialize();
	}

	protected double[][] createTableau(final boolean maximize) {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> constraints = getNormalizedConstraints();
		int width = ((((numDecisionVariables) + (numSlackVariables)) + (numArtificialVariables)) + (getNumObjectiveFunctions())) + 1;
		int height = (constraints.size()) + (getNumObjectiveFunctions());
		double[][] matrix = new double[height][width];
		if ((getNumObjectiveFunctions()) == 2) {
			matrix[0][0] = -1;
		}
		int zIndex = ((getNumObjectiveFunctions()) == 1) ? 0 : 1;
		matrix[zIndex][zIndex] = (maximize) ? 1 : -1;
		org.apache.commons.math.linear.RealVector objectiveCoefficients = (maximize) ? f.getCoefficients().mapMultiply((-1)) : f.getCoefficients();
		copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
		matrix[zIndex][(width - 1)] = (maximize) ? f.getConstantTerm() : (-1) * (f.getConstantTerm());
		if (!(restrictToNonNegative)) {
			matrix[zIndex][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(objectiveCoefficients);
		}
		int slackVar = 0;
		int artificialVar = 0;
		for (int i = 0; i < (constraints.size()); i++) {
			org.apache.commons.math.optimization.linear.LinearConstraint constraint = constraints.get(i);
			int row = (getNumObjectiveFunctions()) + i;
			copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
			if (!(restrictToNonNegative)) {
				matrix[row][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(constraint.getCoefficients());
			}
			matrix[row][(width - 1)] = constraint.getValue();
			if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.LEQ)) {
				matrix[row][((getSlackVariableOffset()) + (slackVar++))] = 1;
			}else
				if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ)) {
					matrix[row][((getSlackVariableOffset()) + (slackVar++))] = -1;
				}
			
			if (((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.EQ)) || ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ))) {
				matrix[0][((getArtificialVariableOffset()) + artificialVar)] = 1;
				matrix[row][((getArtificialVariableOffset()) + (artificialVar++))] = 1;
			}
		}
		return matrix;
	}

	public int getNumVariables() {
		return f.getCoefficients().getDimension();
	}

	public java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> getNormalizedConstraints() {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> normalized = new java.util.ArrayList<org.apache.commons.math.optimization.linear.LinearConstraint>();
		for (org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			normalized.add(normalize(constraint));
		}
		return normalized;
	}

	private org.apache.commons.math.optimization.linear.LinearConstraint normalize(final org.apache.commons.math.optimization.linear.LinearConstraint constraint) {
		if ((constraint.getValue()) < 0) {
			return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients().mapMultiply((-1)), constraint.getRelationship().oppositeRelationship(), ((-1) * (constraint.getValue())));
		}
		return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());
	}

	protected final int getNumObjectiveFunctions() {
		return (this.numArtificialVariables) > 0 ? 2 : 1;
	}

	private int getConstraintTypeCounts(final org.apache.commons.math.optimization.linear.Relationship relationship) {
		int count = 0;
		for (final org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			if ((constraint.getRelationship()) == relationship) {
				++count;
			}
		}
		return count;
	}

	private void initialize() {
		for (int artificialVar = 0; artificialVar < (numArtificialVariables); artificialVar++) {
			int row = getBasicRow(((getArtificialVariableOffset()) + artificialVar));
			subtractRow(0, row, 1.0);
		}
	}

	protected static double getInvertedCoeffiecientSum(final org.apache.commons.math.linear.RealVector coefficients) {
		double sum = 0;
		for (double coefficient : coefficients.getData()) {
			sum -= coefficient;
		}
		return sum;
	}

	private java.lang.Integer getBasicRow(final int col) {
		java.lang.Integer row = null;
		for (int i = getNumObjectiveFunctions(); i < (getHeight()); i++) {
			if (!(org.apache.commons.math.util.MathUtils.equals(getEntry(i, col), 0.0, epsilon))) {
				if (row == null) {
					row = i;
				}else {
					return null;
				}
			}
		}
		return row;
	}

	protected void discardArtificialVariables() {
		if ((numArtificialVariables) == 0) {
			return ;
		}
		int width = ((getWidth()) - (numArtificialVariables)) - 1;
		int height = (getHeight()) - 1;
		double[][] matrix = new double[height][width];
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < (width - 1); j++) {
				matrix[i][j] = getEntry((i + 1), (j + 1));
			}
			matrix[i][(width - 1)] = getEntry((i + 1), getRhsOffset());
		}
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(matrix);
		this.numArtificialVariables = 0;
	}

	private void copyArray(final double[] src, final double[] dest, final int destPos) {
		java.lang.System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
	}

	protected org.apache.commons.math.optimization.RealPointValuePair getSolution() {
		double[] coefficients = new double[getOriginalNumDecisionVariables()];
		java.lang.Integer basicRow = getBasicRow(((getNumObjectiveFunctions()) + (getOriginalNumDecisionVariables())));
		double mostNegative = (basicRow == null) ? 0 : getEntry(basicRow, getRhsOffset());
		java.util.Set<java.lang.Integer> basicRows = new java.util.HashSet<java.lang.Integer>();
		for (int i = 0; i < (coefficients.length); i++) {
			basicRow = getBasicRow(((getNumObjectiveFunctions()) + i));
			if (basicRows.contains(basicRow)) {
				coefficients[i] = 0;
			}else {
				basicRows.add(basicRow);
				coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
			}
		}
		return new org.apache.commons.math.optimization.RealPointValuePair(coefficients, f.getValue(coefficients));
	}

	protected void divideRow(final int dividendRow, final double divisor) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(dividendRow, j, ((tableau.getEntry(dividendRow, j)) / divisor));
		}
	}

	protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(minuendRow, j, ((tableau.getEntry(minuendRow, j)) - (multiple * (tableau.getEntry(subtrahendRow, j)))));
		}
	}

	protected final int getWidth() {
		return tableau.getColumnDimension();
	}

	protected final int getHeight() {
		return tableau.getRowDimension();
	}

	protected final double getEntry(final int row, final int column) {
		return tableau.getEntry(row, column);
	}

	protected final void setEntry(final int row, final int column, final double value) {
		tableau.setEntry(row, column, value);
	}

	protected final int getSlackVariableOffset() {
		return (getNumObjectiveFunctions()) + (numDecisionVariables);
	}

	protected final int getArtificialVariableOffset() {
		return ((getNumObjectiveFunctions()) + (numDecisionVariables)) + (numSlackVariables);
	}

	protected final int getRhsOffset() {
		return (getWidth()) - 1;
	}

	protected final int getNumDecisionVariables() {
		return numDecisionVariables;
	}

	protected final int getOriginalNumDecisionVariables() {
		return restrictToNonNegative ? numDecisionVariables : (numDecisionVariables) - 1;
	}

	protected final int getNumSlackVariables() {
		return numSlackVariables;
	}

	protected final int getNumArtificialVariables() {
		return numArtificialVariables;
	}

	protected final double[][] getData() {
		return tableau.getData();
	}

	@java.lang.Override
	public boolean equals(java.lang.Object other) {
		if ((this) == other) {
			return true;
		}
		if (other == null) {
			return false;
		}
		try {
			org.apache.commons.math.optimization.linear.SimplexTableau rhs = ((org.apache.commons.math.optimization.linear.SimplexTableau) (other));
			return ((((((((restrictToNonNegative) == (rhs.restrictToNonNegative)) && ((numDecisionVariables) == (rhs.numDecisionVariables))) && ((numSlackVariables) == (rhs.numSlackVariables))) && ((numArtificialVariables) == (rhs.numArtificialVariables))) && ((epsilon) == (rhs.epsilon))) && (f.equals(rhs.f))) && (constraints.equals(rhs.constraints))) && (tableau.equals(rhs.tableau));
		} catch (java.lang.ClassCastException ex) {
			return false;
		}
	}

	@java.lang.Override
	public int hashCode() {
		return (((((((java.lang.Boolean.valueOf(restrictToNonNegative).hashCode()) ^ (numDecisionVariables)) ^ (numSlackVariables)) ^ (numArtificialVariables)) ^ (java.lang.Double.valueOf(epsilon).hashCode())) ^ (f.hashCode())) ^ (constraints.hashCode())) ^ (tableau.hashCode());
	}

	private void writeObject(java.io.ObjectOutputStream oos) throws java.io.IOException {
		oos.defaultWriteObject();
		org.apache.commons.math.linear.MatrixUtils.serializeRealMatrix(tableau, oos);
	}

	private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException, java.lang.ClassNotFoundException {
		ois.defaultReadObject();
		org.apache.commons.math.linear.MatrixUtils.deserializeRealMatrix(this, "tableau", ois);
	}
}
2019-04-12 12:57:56,155 ERROR main - Undo Error: modified: 
class SimplexTableau implements java.io.Serializable {
	private static final long serialVersionUID = -1369660067587938365L;

	private final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f;

	private final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints;

	private final boolean restrictToNonNegative;

	protected transient org.apache.commons.math.linear.RealMatrix tableau;

	protected final int numDecisionVariables;

	protected final int numSlackVariables;

	protected int numArtificialVariables;

	protected final double epsilon;

	SimplexTableau(final org.apache.commons.math.optimization.linear.LinearObjectiveFunction f, final java.util.Collection<org.apache.commons.math.optimization.linear.LinearConstraint> constraints, final org.apache.commons.math.optimization.GoalType goalType, final boolean restrictToNonNegative, final double epsilon) {
		this.f = f;
		this.constraints = constraints;
		this.restrictToNonNegative = restrictToNonNegative;
		this.epsilon = epsilon;
		this.numDecisionVariables = (getNumVariables()) + (restrictToNonNegative ? 0 : 1);
		this.numSlackVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.LEQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.numArtificialVariables = (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.EQ)) + (getConstraintTypeCounts(org.apache.commons.math.optimization.linear.Relationship.GEQ));
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(createTableau((goalType == (org.apache.commons.math.optimization.GoalType.MAXIMIZE))));
		initialize();
	}

	protected double[][] createTableau(final boolean maximize) {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> constraints = getNormalizedConstraints();
		int width = ((((numDecisionVariables) + (numSlackVariables)) + (numArtificialVariables)) + (getNumObjectiveFunctions())) + 1;
		int height = (constraints.size()) + (getNumObjectiveFunctions());
		double[][] matrix = new double[height][width];
		if ((getNumObjectiveFunctions()) == 2) {
			matrix[0][0] = -1;
		}
		int zIndex = ((getNumObjectiveFunctions()) == 1) ? 0 : 1;
		matrix[zIndex][zIndex] = (maximize) ? 1 : -1;
		org.apache.commons.math.linear.RealVector objectiveCoefficients = (maximize) ? f.getCoefficients().mapMultiply((-1)) : f.getCoefficients();
		copyArray(objectiveCoefficients.getData(), matrix[zIndex], getNumObjectiveFunctions());
		matrix[zIndex][(width - 1)] = (maximize) ? f.getConstantTerm() : (-1) * (f.getConstantTerm());
		if (!(restrictToNonNegative)) {
			matrix[zIndex][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(objectiveCoefficients);
		}
		int slackVar = 0;
		int artificialVar = 0;
		for (int i = 0; i < (constraints.size()); i++) {
			org.apache.commons.math.optimization.linear.LinearConstraint constraint = constraints.get(i);
			int row = (getNumObjectiveFunctions()) + i;
			copyArray(constraint.getCoefficients().getData(), matrix[row], 1);
			if (!(restrictToNonNegative)) {
				matrix[row][((getSlackVariableOffset()) - 1)] = org.apache.commons.math.optimization.linear.SimplexTableau.getInvertedCoeffiecientSum(constraint.getCoefficients());
			}
			matrix[row][(width - 1)] = constraint.getValue();
			if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.LEQ)) {
				matrix[row][((getSlackVariableOffset()) + (slackVar++))] = 1;
			}else
				if ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ)) {
					matrix[row][((getSlackVariableOffset()) + (slackVar++))] = -1;
				}
			
			if (((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.EQ)) || ((constraint.getRelationship()) == (org.apache.commons.math.optimization.linear.Relationship.GEQ))) {
				matrix[0][((getArtificialVariableOffset()) + artificialVar)] = 1;
				matrix[row][((getArtificialVariableOffset()) + (artificialVar++))] = 1;
			}
		}
		return matrix;
	}

	public int getNumVariables() {
		return f.getCoefficients().getDimension();
	}

	public java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> getNormalizedConstraints() {
		java.util.List<org.apache.commons.math.optimization.linear.LinearConstraint> normalized = new java.util.ArrayList<org.apache.commons.math.optimization.linear.LinearConstraint>();
		for (org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			normalized.add(normalize(constraint));
		}
		return normalized;
	}

	private org.apache.commons.math.optimization.linear.LinearConstraint normalize(final org.apache.commons.math.optimization.linear.LinearConstraint constraint) {
		if ((constraint.getValue()) < 0) {
			return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients().mapMultiply((-1)), constraint.getRelationship().oppositeRelationship(), ((-1) * (constraint.getValue())));
		}
		return new org.apache.commons.math.optimization.linear.LinearConstraint(constraint.getCoefficients(), constraint.getRelationship(), constraint.getValue());
	}

	protected final int getNumObjectiveFunctions() {
		return (this.numArtificialVariables) > 0 ? 2 : 1;
	}

	private int getConstraintTypeCounts(final org.apache.commons.math.optimization.linear.Relationship relationship) {
		int count = 0;
		for (final org.apache.commons.math.optimization.linear.LinearConstraint constraint : constraints) {
			if ((constraint.getRelationship()) == relationship) {
				++count;
			}
		}
		return count;
	}

	private void initialize() {
		for (int artificialVar = 0; artificialVar < (numArtificialVariables); artificialVar++) {
			int row = getBasicRow(((getArtificialVariableOffset()) + artificialVar));
			subtractRow(0, row, 1.0);
		}
	}

	protected static double getInvertedCoeffiecientSum(final org.apache.commons.math.linear.RealVector coefficients) {
		double sum = 0;
		for (double coefficient : coefficients.getData()) {
			sum -= coefficient;
		}
		return sum;
	}

	private java.lang.Integer getBasicRow(final int col) {
		java.lang.Integer row = null;
		for (int i = getNumObjectiveFunctions(); i < (getHeight()); i++) {
			if (!(org.apache.commons.math.util.MathUtils.equals(getEntry(i, col), 0.0, epsilon))) {
				if (row == null) {
					row = i;
				}else {
					return null;
				}
			}
		}
		return row;
	}

	protected void discardArtificialVariables() {
		if ((numArtificialVariables) == 0)
			return ;
		
		int width = ((getWidth()) - (numArtificialVariables)) - 1;
		int height = (getHeight()) - 1;
		double[][] matrix = new double[height][width];
		for (int i = 0; i < height; i++) {
			for (int j = 0; j < (width - 1); j++) {
				matrix[i][j] = getEntry((i + 1), (j + 1));
			}
			matrix[i][(width - 1)] = getEntry((i + 1), getRhsOffset());
		}
		this.tableau = new org.apache.commons.math.linear.RealMatrixImpl(matrix);
		this.numArtificialVariables = 0;
	}

	private void copyArray(final double[] src, final double[] dest, final int destPos) {
		java.lang.System.arraycopy(src, 0, dest, getNumObjectiveFunctions(), src.length);
	}

	protected org.apache.commons.math.optimization.RealPointValuePair getSolution() {
		double[] coefficients = new double[getOriginalNumDecisionVariables()];
		java.lang.Integer basicRow = getBasicRow(((getNumObjectiveFunctions()) + (getOriginalNumDecisionVariables())));
		double mostNegative = (basicRow == null) ? 0 : getEntry(basicRow, getRhsOffset());
		java.util.Set<java.lang.Integer> basicRows = new java.util.HashSet<java.lang.Integer>();
		for (int i = 0; i < (coefficients.length); i++) {
			basicRow = getBasicRow(((getNumObjectiveFunctions()) + i));
			if (basicRows.contains(basicRow)) {
				coefficients[i] = 0;
			}else {
				basicRows.add(basicRow);
				coefficients[i] = (basicRow == null ? 0 : getEntry(basicRow, getRhsOffset())) - (restrictToNonNegative ? 0 : mostNegative);
			}
		}
		return new org.apache.commons.math.optimization.RealPointValuePair(coefficients, f.getValue(coefficients));
	}

	protected void divideRow(final int dividendRow, final double divisor) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(dividendRow, j, ((tableau.getEntry(dividendRow, j)) / divisor));
		}
	}

	protected void subtractRow(final int minuendRow, final int subtrahendRow, final double multiple) {
		for (int j = 0; j < (getWidth()); j++) {
			tableau.setEntry(minuendRow, j, ((tableau.getEntry(minuendRow, j)) - (multiple * (tableau.getEntry(subtrahendRow, j)))));
		}
	}

	protected final int getWidth() {
		return tableau.getColumnDimension();
	}

	protected final int getHeight() {
		return tableau.getRowDimension();
	}

	protected final double getEntry(final int row, final int column) {
		return tableau.getEntry(row, column);
	}

	protected final void setEntry(final int row, final int column, final double value) {
		tableau.setEntry(row, column, value);
	}

	protected final int getSlackVariableOffset() {
		return (getNumObjectiveFunctions()) + (numDecisionVariables);
	}

	protected final int getArtificialVariableOffset() {
		return ((getNumObjectiveFunctions()) + (numDecisionVariables)) + (numSlackVariables);
	}

	protected final int getRhsOffset() {
		return (getWidth()) - 1;
	}

	protected final int getNumDecisionVariables() {
		return numDecisionVariables;
	}

	protected final int getOriginalNumDecisionVariables() {
		return restrictToNonNegative ? numDecisionVariables : (numDecisionVariables) - 1;
	}

	protected final int getNumSlackVariables() {
		return numSlackVariables;
	}

	protected final int getNumArtificialVariables() {
		return numArtificialVariables;
	}

	protected final double[][] getData() {
		return tableau.getData();
	}

	@java.lang.Override
	public boolean equals(java.lang.Object other) {
		if ((this) == other) {
			return true;
		}
		if (other == null) {
			return false;
		}
		try {
			org.apache.commons.math.optimization.linear.SimplexTableau rhs = ((org.apache.commons.math.optimization.linear.SimplexTableau) (other));
			return ((((((((restrictToNonNegative) == (rhs.restrictToNonNegative)) && ((numDecisionVariables) == (rhs.numDecisionVariables))) && ((numSlackVariables) == (rhs.numSlackVariables))) && ((numArtificialVariables) == (rhs.numArtificialVariables))) && ((epsilon) == (rhs.epsilon))) && (f.equals(rhs.f))) && (constraints.equals(rhs.constraints))) && (tableau.equals(rhs.tableau));
		} catch (java.lang.ClassCastException ex) {
			return false;
		}
	}

	@java.lang.Override
	public int hashCode() {
		return (((((((java.lang.Boolean.valueOf(restrictToNonNegative).hashCode()) ^ (numDecisionVariables)) ^ (numSlackVariables)) ^ (numArtificialVariables)) ^ (java.lang.Double.valueOf(epsilon).hashCode())) ^ (f.hashCode())) ^ (constraints.hashCode())) ^ (tableau.hashCode());
	}

	private void writeObject(java.io.ObjectOutputStream oos) throws java.io.IOException {
		oos.defaultWriteObject();
		org.apache.commons.math.linear.MatrixUtils.serializeRealMatrix(tableau, oos);
	}

	private void readObject(java.io.ObjectInputStream ois) throws java.io.IOException, java.lang.ClassNotFoundException {
		ois.defaultReadObject();
		org.apache.commons.math.linear.MatrixUtils.deserializeRealMatrix(this, "tableau", ois);
	}
}
2019-04-12 13:02:12,468 INFO main - Time Repair Loop (s): 269.505
2019-04-12 13:02:12,469 INFO main - 
----SUMMARY_EXECUTION---
2019-04-12 13:02:12,470 INFO main - 
successful_ing_attempts (0): []
2019-04-12 13:02:12,471 INFO main - 
failing_ing_attempts (381): [2, 1, 0, 0, 0, 0, 0, 2, 0, 1, 5, 0, 2, 3, 1, 1, 6, 4, 1, 1, 2, 0, 1, 5, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 8, 4, 2, 11, 0, 1, 1, 1, 1, 1, 3, 0, 6, 1, 2, 0, 1, 2, 0, 2, 3, 0, 2, 0, 2, 1, 1, 5, 4, 1, 6, 1, 0, 1, 1, 1, 2, 0, 0, 2, 2, 5, 0, 3, 1, 3, 2, 0, 2, 1, 1, 1, 1, 3, 0, 4, 4, 1, 0, 0, 3, 2, 1, 2, 3, 1, 0, 3, 3, 2, 1, 6, 1, 0, 1, 8, 4, 1, 0, 1, 3, 3, 5, 2, 1, 1, 0, 6, 0, 2, 2, 0, 0, 1, 3, 3, 0, 2, 3, 3, 1, 1, 1, 0, 1, 2, 1, 0, 1, 0, 4, 0, 3, 0, 1, 0, 2, 1, 2, 1, 0, 0, 2, 3, 0, 1, 0, 0, 0, 1, 0, 1, 3, 0, 0, 1, 0, 0, 2, 0, 0, 4, 2, 1, 4, 1, 7, 1, 3, 1, 1, 0, 0, 3, 4, 1, 0, 0, 0, 0, 0, 2, 1, 2, 0, 5, 0, 0, 1, 1, 0, 0, 0, 2, 0, 0, 1, 0, 10, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
2019-04-12 13:02:12,471 INFO fr.inria.main.evolution.AstorMain - Time Total(s): 331.791
[DONE]
