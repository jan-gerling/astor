2019-04-12 11:11:45,637 INFO main - command line arguments: [-jvm4testexecution  /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin  -mode  jgenprog  -scope  local  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -location  defect4j_tests/math_86/  -dependencies  ./examples/libs/junit-4.4.jar  -flthreshold  0.5  -maxtime  100  -stopfirst  true]
2019-04-12 11:11:48,054 INFO main - -Executing Gzoltar classpath: /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//bin//default from 194 classes with test cases
2019-04-12 11:11:48,054 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar fault localization: min susp value parameter: 0.5
2019-04-12 11:11:49,680 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - -gz-Adding classpath: [/home/jan_gerling/astor/./examples/libs/junit-4.4.jar, /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//bin//default]
2019-04-12 11:12:08,273 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.CholeskyDecompositionImplTest#testMath274
2019-04-12 11:12:08,284 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.math.linear.CholeskyDecompositionImplTest#testNotPositiveDefinite
2019-04-12 11:12:08,294 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar Test Result Total:1894, fails: 2, GZoltar suspicious 15672
2019-04-12 11:12:08,391 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar found: 1000 with susp > 0.5, we consider: 1000
2019-04-12 11:12:08,423 INFO main - building model: /home/jan_gerling/astor/./outputMutation/AstorMain-math_86//src//default, compliance level: 8
2019-04-12 11:12:24,539 INFO main - 
---- Initial suspicious size: 994
2019-04-12 11:12:27,168 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 11:12:27,962 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 11:12:28,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 11:12:28,329 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 11:12:28,416 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:28,421 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:28,426 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:28,428 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:12:28,470 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:28,472 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:12:28,519 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 11:12:28,592 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 11:12:28,612 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:28,633 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:28,636 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:12:28,639 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:28,649 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:28,650 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:28,657 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 11:12:28,684 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 11:12:28,738 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 11:12:28,755 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 11:12:28,761 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:28,763 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:12:28,806 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 11:12:28,812 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 11:12:28,834 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 11:12:28,862 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 11:12:28,875 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:12:28,876 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:12:28,876 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:12:28,877 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:12:28,877 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:12:28,878 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:12:28,878 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:12:28,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:12:28,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:28,887 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:28,887 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:12:28,887 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:12:28,887 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:12:28,887 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:12:28,887 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:12:28,887 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:12:28,887 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:12:28,887 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:12:28,887 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:12:28,887 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:12:28,887 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:12:28,888 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:12:28,888 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:12:28,892 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:28,894 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:28,918 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:29,080 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 11:12:29,106 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:29,107 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:29,107 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:12:29,107 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:12:29,107 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:12:29,107 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:12:29,107 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:12:29,107 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:12:29,184 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 11:12:29,187 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 11:12:29,217 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 11:12:29,277 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 11:12:29,341 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 11:12:29,419 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:12:29,480 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:29,535 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 11:12:29,538 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 11:12:29,596 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:29,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:29,676 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:30,395 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 11:12:30,397 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 11:12:30,432 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 11:12:30,434 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:12:30,455 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 11:12:30,457 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 11:12:30,459 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 11:12:30,463 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 11:12:30,467 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 11:12:30,493 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 11:12:30,551 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:30,597 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:30,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 11:12:30,625 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 11:12:30,651 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 11:12:30,666 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 11:12:30,715 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 11:12:30,718 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 11:12:30,719 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:12:30,719 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:12:30,719 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:12:30,719 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:12:30,719 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:12:30,719 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:12:30,719 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:12:30,719 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:12:30,719 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:12:30,732 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:12:30,732 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:12:30,732 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:12:30,732 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:12:30,732 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:12:30,732 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:12:30,732 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:12:30,732 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:12:30,732 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:12:31,030 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 11:12:31,050 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 11:12:31,098 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 11:12:31,099 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:31,103 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:31,219 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 11:12:31,226 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 11:12:31,237 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 11:12:31,280 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 11:12:31,343 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 11:12:31,350 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 11:12:31,354 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 11:12:31,357 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 11:12:31,378 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 11:12:31,389 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 11:12:31,473 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 11:12:31,499 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 11:12:31,506 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 11:12:31,514 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 11:12:31,543 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 11:12:31,910 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 11:12:31,976 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 11:12:32,010 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 11:12:32,074 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 11:12:32,137 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 11:12:32,241 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 11:12:32,264 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 11:12:32,308 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 11:12:32,312 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 11:12:32,386 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 11:12:32,392 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:32,392 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:32,392 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:32,392 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:32,392 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:12:32,395 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:12:32,400 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:32,400 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:32,404 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:12:32,404 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:12:32,404 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:32,404 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:32,437 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 11:12:32,460 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 11:12:32,491 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 11:12:32,499 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 11:12:32,522 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 11:12:32,573 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 11:12:32,593 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 11:12:32,598 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 11:12:32,615 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 11:12:32,617 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 11:12:32,685 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 11:12:32,759 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 11:12:32,778 INFO main - Total suspicious from FL: 994,  811
2019-04-12 11:12:32,778 INFO main - Total ModPoint created: 811
2019-04-12 11:12:32,778 INFO main - Creating program variant #1, [Variant id: 1, #gens: 811, #ops: 0, parent:-]
2019-04-12 11:12:34,079 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 11:12:34,721 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 11:12:34,863 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 11:12:35,094 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 11:12:35,165 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:35,194 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:35,209 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:35,212 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:12:35,261 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:35,265 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:12:35,305 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 11:12:35,368 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 11:12:35,372 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:35,379 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:35,382 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:12:35,387 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:35,389 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:35,390 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:35,394 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 11:12:35,407 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 11:12:35,436 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 11:12:35,454 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 11:12:35,459 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:35,462 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:12:35,515 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 11:12:35,543 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 11:12:35,557 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 11:12:35,595 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:12:35,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:12:35,620 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:12:35,621 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:12:35,622 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:12:35,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:12:35,623 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:35,623 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:35,625 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:35,625 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:35,629 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:12:35,631 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:12:35,631 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:12:35,632 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:12:35,632 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:12:35,636 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:35,638 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:35,655 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:35,849 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 11:12:35,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:35,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:35,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:12:35,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:12:35,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:12:35,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:12:35,879 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:12:35,879 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:12:35,930 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 11:12:35,933 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 11:12:35,955 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 11:12:35,992 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 11:12:36,052 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 11:12:36,177 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:12:36,220 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:36,298 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 11:12:36,301 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 11:12:36,431 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:36,476 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:36,522 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:37,032 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 11:12:37,034 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 11:12:37,056 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 11:12:37,058 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:12:37,099 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 11:12:37,113 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 11:12:37,115 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 11:12:37,120 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 11:12:37,135 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 11:12:37,160 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 11:12:37,208 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:37,234 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:37,245 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 11:12:37,250 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 11:12:37,263 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 11:12:37,266 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 11:12:37,292 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 11:12:37,295 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:12:37,296 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:12:37,296 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:12:37,298 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:12:37,298 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:12:37,529 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 11:12:37,536 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 11:12:37,560 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 11:12:37,562 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:37,563 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:37,742 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 11:12:37,750 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 11:12:37,772 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 11:12:37,855 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 11:12:37,995 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 11:12:38,015 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 11:12:38,019 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 11:12:38,023 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 11:12:38,073 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 11:12:38,106 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 11:12:38,245 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 11:12:38,321 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 11:12:38,341 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 11:12:38,349 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 11:12:38,416 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 11:12:38,551 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 11:12:38,614 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 11:12:38,643 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 11:12:38,712 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 11:12:38,761 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 11:12:38,873 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 11:12:38,896 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 11:12:38,956 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 11:12:38,960 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 11:12:39,039 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 11:12:39,046 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:39,047 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:39,047 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:39,048 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:39,048 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:12:39,048 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:12:39,048 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:39,049 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:39,049 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:12:39,049 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:12:39,049 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:39,049 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:39,067 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 11:12:39,077 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 11:12:39,094 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 11:12:39,102 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 11:12:39,113 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 11:12:39,147 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 11:12:39,170 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 11:12:39,175 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 11:12:39,179 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 11:12:39,196 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 11:12:39,253 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 11:12:39,293 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 11:12:39,307 INFO main - Total suspicious from FL: 994,  811
2019-04-12 11:12:39,307 INFO main - Total ModPoint created: 811
2019-04-12 11:12:39,307 INFO main - Creating program variant #2, [Variant id: 2, #gens: 811, #ops: 0, parent:-]
2019-04-12 11:12:40,120 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{multiply(Lorg/apache/commons/math/linear/RealMatrix;)Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.0944911182523068]
2019-04-12 11:12:40,549 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DenseRealMatrix, methodName=org.apache.commons.math.linear.DenseRealMatrix{transpose()Lorg/apache/commons/math/linear/RealMatrix; 0.0, lineNumber=64, susp=0.079555728417573]
2019-04-12 11:12:40,748 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.MatrixUtils, methodName=org.apache.commons.math.linear.MatrixUtils{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/AnyMatrix;Lorg/apache/commons/math/linear/AnyMatrix;)V 0.0, lineNumber=633, susp=0.07495316889958614]
2019-04-12 11:12:40,904 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.Variance, methodName=org.apache.commons.math.stat.descriptive.moment.Variance{clear()V 0.0, lineNumber=194, susp=0.0]
2019-04-12 11:12:40,938 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{increment(D)V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:40,942 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.FirstMoment, methodName=org.apache.commons.math.stat.descriptive.moment.FirstMoment{clear()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:40,946 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:40,947 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.Sum, methodName=org.apache.commons.math.stat.descriptive.summary.Sum{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:12:40,959 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:40,961 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Min, methodName=org.apache.commons.math.stat.descriptive.rank.Min{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:12:40,992 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{addValue(D)V 0.0, lineNumber=164, susp=0.0]
2019-04-12 11:12:41,035 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.SummaryStatistics, methodName=org.apache.commons.math.stat.descriptive.SummaryStatistics{clear()V 0.0, lineNumber=330, susp=0.0]
2019-04-12 11:12:41,042 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.GeometricMean, methodName=org.apache.commons.math.stat.descriptive.moment.GeometricMean{clear()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:41,047 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:41,049 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfSquares, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfSquares{clear()V 0.0, lineNumber=102, susp=0.0]
2019-04-12 11:12:41,052 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:41,053 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:41,054 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:41,055 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.moment.SecondMoment, methodName=org.apache.commons.math.stat.descriptive.moment.SecondMoment{clear()V 0.0, lineNumber=91, susp=0.0]
2019-04-12 11:12:41,067 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{addValue(D)V 0.0, lineNumber=149, susp=0.0]
2019-04-12 11:12:41,082 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.DescriptiveStatistics, methodName=org.apache.commons.math.stat.descriptive.DescriptiveStatistics{clear()V 0.0, lineNumber=280, susp=0.0]
2019-04-12 11:12:41,087 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Percentile, methodName=org.apache.commons.math.stat.descriptive.rank.Percentile{setQuantile(D)V 0.0, lineNumber=254, susp=0.0]
2019-04-12 11:12:41,091 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{increment(D)V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:41,092 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.rank.Max, methodName=org.apache.commons.math.stat.descriptive.rank.Max{clear()V 0.0, lineNumber=87, susp=0.0]
2019-04-12 11:12:41,108 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{addElement(D)V 0.0, lineNumber=275, susp=0.0]
2019-04-12 11:12:41,112 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{clear()V 0.0, lineNumber=379, susp=0.0]
2019-04-12 11:12:41,120 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{contract()V 0.0, lineNumber=395, susp=0.0]
2019-04-12 11:12:41,130 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.ResizableDoubleArray, methodName=org.apache.commons.math.util.ResizableDoubleArray{expand()V 0.0, lineNumber=496, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Ljava/lang/String;DDD)V 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=48, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=50, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=52, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{setUp()V 0.0, lineNumber=53, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=56, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=59, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=60, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=62, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=63, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=68, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=71, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=72, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=73, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=75, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=76, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=77, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=78, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=80, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:12:41,139 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=81, susp=0.0]
2019-04-12 11:12:41,139 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=83, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=86, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=89, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=90, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{loadData()V 0.0, lineNumber=93, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getMaximumAbsoluteError()D 0.0, lineNumber=98, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=103, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=104, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=106, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=107, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=109, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{tearDown()V 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=114, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=118, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=119, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=120, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=121, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=124, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=125, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=126, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=127, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=128, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=130, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{testCertifiedValues()V 0.0, lineNumber=131, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=137, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=138, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=139, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=140, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=141, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=142, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=143, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=153, susp=0.0]
2019-04-12 11:12:41,140 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:12:41,140 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.data.CertifiedDataAbstractTest, methodName=org.apache.commons.math.stat.data.CertifiedDataAbstractTest{getProperty(Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Double; 0.0, lineNumber=154, susp=0.0]
2019-04-12 11:12:41,143 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{increment(D)V 0.0, lineNumber=82, susp=0.0]
2019-04-12 11:12:41,145 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.stat.descriptive.summary.SumOfLogs, methodName=org.apache.commons.math.stat.descriptive.summary.SumOfLogs{clear()V 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:41,154 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField$LazyHolder, methodName=org.apache.commons.math.fraction.FractionField$LazyHolder{access$000()Lorg/apache/commons/math/fraction/FractionField; 0.0, lineNumber=65, susp=0.0]
2019-04-12 11:12:41,248 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.util.MathUtils, methodName=org.apache.commons.math.util.MathUtils{gcd(II)I 0.0, lineNumber=661, susp=0.0]
2019-04-12 11:12:41,261 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:41,262 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:41,262 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:12:41,262 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=348, susp=0.0]
2019-04-12 11:12:41,262 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:12:41,262 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=349, susp=0.0]
2019-04-12 11:12:41,262 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:12:41,262 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals([Lorg/apache/commons/math/FieldElement;[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=351, susp=0.0]
2019-04-12 11:12:41,332 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=335, susp=0.0]
2019-04-12 11:12:41,334 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=339, susp=0.0]
2019-04-12 11:12:41,351 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{operate([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=414, susp=0.0]
2019-04-12 11:12:41,374 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{copyIn([[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=615, susp=0.0]
2019-04-12 11:12:41,512 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{buildArray(Lorg/apache/commons/math/Field;II)[[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=94, susp=0.0]
2019-04-12 11:12:41,603 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getZero()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:12:41,622 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{equals(Ljava/lang/Object;)Z 0.0, lineNumber=345, susp=0.0]
2019-04-12 11:12:41,699 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=551, susp=0.0]
2019-04-12 11:12:41,703 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Lorg/apache/commons/math/fraction/Fraction;)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=552, susp=0.0]
2019-04-12 11:12:41,773 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{getField()Lorg/apache/commons/math/Field; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:41,815 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{multiply(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:41,849 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{add(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:42,428 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=364, susp=0.0]
2019-04-12 11:12:42,430 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setEntry(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=365, susp=0.0]
2019-04-12 11:12:42,462 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1138, susp=0.0]
2019-04-12 11:12:42,464 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.FractionField, methodName=org.apache.commons.math.fraction.FractionField{getOne()Ljava/lang/Object; 0.0, lineNumber=33, susp=0.0]
2019-04-12 11:12:42,515 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=501, susp=0.0]
2019-04-12 11:12:42,517 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=502, susp=0.0]
2019-04-12 11:12:42,520 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=503, susp=0.0]
2019-04-12 11:12:42,524 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=509, susp=0.0]
2019-04-12 11:12:42,528 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=511, susp=0.0]
2019-04-12 11:12:42,567 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{addSub(Lorg/apache/commons/math/fraction/Fraction;Z)Lorg/apache/commons/math/fraction/Fraction; 0.0, lineNumber=525, susp=0.0]
2019-04-12 11:12:42,620 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{divide(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:42,663 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.fraction.Fraction, methodName=org.apache.commons.math.fraction.Fraction{subtract(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=34, susp=0.0]
2019-04-12 11:12:42,673 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=347, susp=0.0]
2019-04-12 11:12:42,690 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{getEntry(II)Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=350, susp=0.0]
2019-04-12 11:12:42,720 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1106, susp=0.0]
2019-04-12 11:12:42,723 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1107, susp=0.0]
2019-04-12 11:12:42,778 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1103, susp=0.0]
2019-04-12 11:12:42,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkAdditionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1109, susp=0.0]
2019-04-12 11:12:42,793 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:12:42,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=287, susp=0.0]
2019-04-12 11:12:42,793 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:12:42,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=291, susp=0.0]
2019-04-12 11:12:42,793 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:12:42,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=292, susp=0.0]
2019-04-12 11:12:42,793 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:12:42,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=302, susp=0.0]
2019-04-12 11:12:42,793 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:12:42,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=303, susp=0.0]
2019-04-12 11:12:42,793 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:12:42,793 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=304, susp=0.0]
2019-04-12 11:12:42,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:12:42,794 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=305, susp=0.0]
2019-04-12 11:12:42,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:12:42,794 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=306, susp=0.0]
2019-04-12 11:12:42,794 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:12:42,794 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{assertEquals(Lorg/apache/commons/math/linear/FieldMatrix;Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=309, susp=0.0]
2019-04-12 11:12:43,149 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1028, susp=0.0]
2019-04-12 11:12:43,156 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1041, susp=0.0]
2019-04-12 11:12:43,184 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1070, susp=0.0]
2019-04-12 11:12:43,185 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixPreservingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:43,186 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor, methodName=org.apache.commons.math.linear.DefaultFieldMatrixChangingVisitor{start(IIIIII)V 0.0, lineNumber=49, susp=0.0]
2019-04-12 11:12:43,290 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=455, susp=0.0]
2019-04-12 11:12:43,297 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=458, susp=0.0]
2019-04-12 11:12:43,307 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=464, susp=0.0]
2019-04-12 11:12:43,361 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkRowIndex(I)V 0.0, lineNumber=1026, susp=0.0]
2019-04-12 11:12:43,480 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1118, susp=0.0]
2019-04-12 11:12:43,487 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1121, susp=0.0]
2019-04-12 11:12:43,490 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1122, susp=0.0]
2019-04-12 11:12:43,493 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubtractionCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1124, susp=0.0]
2019-04-12 11:12:43,538 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=514, susp=0.0]
2019-04-12 11:12:43,561 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRowVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=520, susp=0.0]
2019-04-12 11:12:43,710 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix(IIII[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=372, susp=0.0]
2019-04-12 11:12:43,759 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{copySubMatrix([I[I[[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=396, susp=0.0]
2019-04-12 11:12:43,774 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkColumnIndex(I)V 0.0, lineNumber=1039, susp=0.0]
2019-04-12 11:12:43,781 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex(IIII)V 0.0, lineNumber=1059, susp=0.0]
2019-04-12 11:12:43,846 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkSubMatrixIndex([I[I)V 0.0, lineNumber=1094, susp=0.0]
2019-04-12 11:12:44,003 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{start(IIIIII)V 0.0, lineNumber=362, susp=0.0]
2019-04-12 11:12:44,177 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$2, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$2{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=368, susp=0.0]
2019-04-12 11:12:44,201 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{preMultiply([Lorg/apache/commons/math/FieldElement;)[Lorg/apache/commons/math/FieldElement; 0.0, lineNumber=438, susp=0.0]
2019-04-12 11:12:44,276 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix(IIII)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=294, susp=0.0]
2019-04-12 11:12:44,306 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{getSubMatrix([I[I)Lorg/apache/commons/math/linear/FieldMatrix; 0.0, lineNumber=314, susp=0.0]
2019-04-12 11:12:44,355 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=601, susp=0.0]
2019-04-12 11:12:44,365 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumn(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=607, susp=0.0]
2019-04-12 11:12:44,397 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1135, susp=0.0]
2019-04-12 11:12:44,401 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{checkMultiplicationCompatible(Lorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=1136, susp=0.0]
2019-04-12 11:12:44,548 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix$3, methodName=org.apache.commons.math.linear.AbstractFieldMatrix$3{visit(IILorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=637, susp=0.0]
2019-04-12 11:12:44,566 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:44,566 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=110, susp=0.0]
2019-04-12 11:12:44,566 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:44,566 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=111, susp=0.0]
2019-04-12 11:12:44,566 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:12:44,566 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=112, susp=0.0]
2019-04-12 11:12:44,566 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:44,566 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=115, susp=0.0]
2019-04-12 11:12:44,566 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:12:44,566 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=116, susp=0.0]
2019-04-12 11:12:44,566 INFO main -  Not ctClass for suspicious code Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:44,566 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.TestUtils, methodName=org.apache.commons.math.TestUtils{serializeAndRecover(Ljava/lang/Object;)Ljava/lang/Object; 0.0, lineNumber=117, susp=0.0]
2019-04-12 11:12:44,608 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=569, susp=0.0]
2019-04-12 11:12:44,630 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setRow(I[Lorg/apache/commons/math/FieldElement;)V 0.0, lineNumber=575, susp=0.0]
2019-04-12 11:12:44,650 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=488, susp=0.0]
2019-04-12 11:12:44,669 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=491, susp=0.0]
2019-04-12 11:12:44,679 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnMatrix(ILorg/apache/commons/math/linear/FieldMatrix;)V 0.0, lineNumber=497, susp=0.0]
2019-04-12 11:12:44,723 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=537, susp=0.0]
2019-04-12 11:12:44,759 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setColumnVector(ILorg/apache/commons/math/linear/FieldVector;)V 0.0, lineNumber=543, susp=0.0]
2019-04-12 11:12:44,764 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=310, susp=0.0]
2019-04-12 11:12:44,778 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=315, susp=0.0]
2019-04-12 11:12:44,780 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.FieldMatrixImpl, methodName=org.apache.commons.math.linear.FieldMatrixImpl{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=336, susp=0.0]
2019-04-12 11:12:44,841 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=416, susp=0.0]
2019-04-12 11:12:44,906 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.math.linear.AbstractFieldMatrix, methodName=org.apache.commons.math.linear.AbstractFieldMatrix{setSubMatrix([[Lorg/apache/commons/math/FieldElement;II)V 0.0, lineNumber=431, susp=0.0]
2019-04-12 11:12:44,914 INFO main - Total suspicious from FL: 994,  811
2019-04-12 11:12:44,914 INFO main - Total ModPoint created: 811
2019-04-12 11:12:44,914 INFO main - Creating program variant #3, [Variant id: 3, #gens: 811, #ops: 0, parent:-]
2019-04-12 11:13:05,800 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 11:13:05,800 INFO fr.inria.astor.core.setup.ConfigurationProperties - ---Configuration properties:---Execution values
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:faultlocalization= fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:packageToInstrument= 
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:flthreshold= 0.5
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:numberExecutions= 1
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuiteresultfolder= evosuite
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoredTestCases= 
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:skipfaultlocalization= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxGeneration= 200
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxsuspcandidates= 1000
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax2= 960000
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax1= 120000
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:workingDirectory= /home/jan_gerling/astor/./outputMutation
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mode= jgenprog
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoreflakyinfl= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:uniqueoptogen= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pathToMVNRepository= 
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:timezone= America/Los_Angeles
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:applyCrossover= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clonegranularity= types
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:modificationpointnavigation= weight
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clusteringfilename= clustering.csv
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxtime= 100
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:probagenmutation= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:alternativecompliancelevel= 4
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:version-location= ./math-version/
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:location= defect4j_tests/math_86/
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:filterfaultlocalization= true
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:stopfirst= true
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4testexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bugId= 280
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mutationrate= 1 
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:forceExecuteRegression= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:projectIdentifier= 
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_buggy_class= true
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoRunOnBuggyClass= true
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resetoperations= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4evosuitetestexecution= /usr/lib/jvm/java-1.8.0-openjdk-amd64/bin
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:seed= 0
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:testbystep= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srctestfolder= /src/test/
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:javacompliancelevel= 8
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bintestfolder= /target/test-classes/
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:fitnessfunction= fr.inria.astor.core.loop.population.TestCaseFitnessFunction
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:commandTrunk= 50000
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:dependenciespath= ./examples/libs/junit-4.4.jar
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:multipointmodification= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:transformingredient= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:validation= process
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:scope= local
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitetimeout= 120
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoDSE= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:elementsToMutate= 10
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:allpoints= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resourcesfolder= /src/main/resources:/src/test/resources:
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:regressionforfaultlocalization= true
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:population= 3
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:saveall= false
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pvariantfoldername= variant-
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:populationcontroller= fr.inria.astor.core.loop.population.TestCaseBasedFitnessPopulationController
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:savesolution= true
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srcjavafolder= /src/java/
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_affected_by_op= true
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:binjavafolder= /target/classes/
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:reintroduce= original-parents
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:learningdir= 
2019-04-12 11:13:05,811 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-12 11:13:05,811 INFO main - 
----Starting Solution Search
2019-04-12 11:13:47,363 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:13:47,375 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:13:47,408 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:13:49,078 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:13:49,078 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null) {
			cachedL = getLT().transpose();
		}
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:13:49,080 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:15:51,528 INFO main - The Process that runs JUnit test cases had problems: process hasn't exited
2019-04-12 11:16:21,453 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:16:21,453 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null) {
			cachedL = getLT().transpose();
		}
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:16:21,455 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:16:31,323 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:16:31,323 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:16:31,342 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:17:18,157 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:17:18,157 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:17:18,198 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:18:22,963 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:18:22,963 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:18:22,982 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:19:32,267 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:19:32,267 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:19:32,273 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:19:44,064 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:19:44,064 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0) {
				res.append(",");
			}
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:19:44,070 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:20:30,911 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:20:30,911 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:20:30,916 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null)
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:20:35,670 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:20:35,671 ERROR main - Undo Error: original: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null) {
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		}
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:20:35,687 ERROR main - Undo Error: modified: 
public class CholeskyDecompositionImpl implements org.apache.commons.math.linear.CholeskyDecomposition {
	public static final double DEFAULT_RELATIVE_SYMMETRY_THRESHOLD = 1.0E-15;

	public static final double DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD = 1.0E-10;

	private double[][] lTData;

	private org.apache.commons.math.linear.RealMatrix cachedL;

	private org.apache.commons.math.linear.RealMatrix cachedLT;

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		this(matrix, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_RELATIVE_SYMMETRY_THRESHOLD, org.apache.commons.math.linear.CholeskyDecompositionImpl.DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD);
	}

	public CholeskyDecompositionImpl(final org.apache.commons.math.linear.RealMatrix matrix, final double relativeSymmetryThreshold, final double absolutePositivityThreshold) throws org.apache.commons.math.linear.NonSquareMatrixException, org.apache.commons.math.linear.NotPositiveDefiniteMatrixException, org.apache.commons.math.linear.NotSymmetricMatrixException {
		if (!(matrix.isSquare())) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(matrix.getRowDimension(), matrix.getColumnDimension());
		}
		final int order = matrix.getRowDimension();
		lTData = matrix.getData();
		cachedL = null;
		cachedLT = null;
		for (int i = 0; i < order; ++i) {
			final double[] lI = lTData[i];
			if ((lTData[i][i]) < absolutePositivityThreshold) {
				throw new org.apache.commons.math.linear.NotPositiveDefiniteMatrixException();
			}
			for (int j = i + 1; j < order; ++j) {
				final double[] lJ = lTData[j];
				final double lIJ = lI[j];
				final double lJI = lJ[i];
				final double maxDelta = relativeSymmetryThreshold * (java.lang.Math.max(java.lang.Math.abs(lIJ), java.lang.Math.abs(lJI)));
				if ((java.lang.Math.abs((lIJ - lJI))) > maxDelta) {
					throw new org.apache.commons.math.linear.NotSymmetricMatrixException();
				}
				lJ[i] = 0;
			}
		}
		for (int i = 0; i < order; ++i) {
			final double[] ltI = lTData[i];
			ltI[i] = java.lang.Math.sqrt(ltI[i]);
			final double inverse = 1.0 / (ltI[i]);
			for (int q = order - 1; q > i; --q) {
				ltI[q] *= inverse;
				final double[] ltQ = lTData[q];
				for (int p = q; p < order; ++p) {
					ltQ[p] -= (ltI[q]) * (ltI[p]);
				}
			}
		}
	}

	public org.apache.commons.math.linear.RealMatrix getL() {
		if ((cachedL) == null)
			cachedL = getLT().transpose();
		
		return cachedL;
	}

	public org.apache.commons.math.linear.RealMatrix getLT() {
		if ((cachedLT) == null)
			cachedLT = org.apache.commons.math.linear.MatrixUtils.createRealMatrix(lTData);
		
		return cachedLT;
	}

	public double getDeterminant() {
		double determinant = 1.0;
		for (int i = 0; i < (lTData.length); ++i) {
			double lTii = lTData[i][i];
			determinant *= lTii * lTii;
		}
		return determinant;
	}

	public org.apache.commons.math.linear.DecompositionSolver getSolver() {
		return new org.apache.commons.math.linear.CholeskyDecompositionImpl.Solver(lTData);
	}

	private static class Solver implements org.apache.commons.math.linear.DecompositionSolver {
		private final double[][] lTData;

		private Solver(final double[][] lTData) {
			this.lTData = lTData;
		}

		public boolean isNonSingular() {
			return true;
		}

		public double[] solve(double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.length) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.length, m);
			}
			final double[] x = b.clone();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				x[j] /= lJ[j];
				final double xJ = x[j];
				for (int i = j + 1; i < m; i++) {
					x[i] -= xJ * (lJ[i]);
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				x[j] /= lTData[j][j];
				final double xJ = x[j];
				for (int i = 0; i < j; i++) {
					x[i] -= xJ * (lTData[i][j]);
				}
			}
			return x;
		}

		public org.apache.commons.math.linear.RealVector solve(org.apache.commons.math.linear.RealVector b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			try {
				return solve(((org.apache.commons.math.linear.RealVectorImpl) (b)));
			} catch (java.lang.ClassCastException cce) {
				final int m = lTData.length;
				if ((b.getDimension()) != m) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", b.getDimension(), m);
				}
				final double[] x = b.getData();
				for (int j = 0; j < m; j++) {
					final double[] lJ = lTData[j];
					x[j] /= lJ[j];
					final double xJ = x[j];
					for (int i = j + 1; i < m; i++) {
						x[i] -= xJ * (lJ[i]);
					}
				}
				for (int j = m - 1; j >= 0; j--) {
					x[j] /= lTData[j][j];
					final double xJ = x[j];
					for (int i = 0; i < j; i++) {
						x[i] -= xJ * (lTData[i][j]);
					}
				}
				return new org.apache.commons.math.linear.RealVectorImpl(x, false);
			}
		}

		public org.apache.commons.math.linear.RealVectorImpl solve(org.apache.commons.math.linear.RealVectorImpl b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			return new org.apache.commons.math.linear.RealVectorImpl(solve(b.getDataRef()), false);
		}

		public org.apache.commons.math.linear.RealMatrix solve(org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
			final int m = lTData.length;
			if ((b.getRowDimension()) != m) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", b.getRowDimension(), b.getColumnDimension(), m, "n");
			}
			final int nColB = b.getColumnDimension();
			double[][] x = b.getData();
			for (int j = 0; j < m; j++) {
				final double[] lJ = lTData[j];
				final double lJJ = lJ[j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = j + 1; i < m; i++) {
					final double[] xI = x[i];
					final double lJI = lJ[i];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lJI;
					}
				}
			}
			for (int j = m - 1; j >= 0; j--) {
				final double lJJ = lTData[j][j];
				final double[] xJ = x[j];
				for (int k = 0; k < nColB; ++k) {
					xJ[k] /= lJJ;
				}
				for (int i = 0; i < j; i++) {
					final double[] xI = x[i];
					final double lIJ = lTData[i][j];
					for (int k = 0; k < nColB; ++k) {
						xI[k] -= (xJ[k]) * lIJ;
					}
				}
			}
			return new org.apache.commons.math.linear.RealMatrixImpl(x, false);
		}

		public org.apache.commons.math.linear.RealMatrix getInverse() throws org.apache.commons.math.linear.InvalidMatrixException {
			return solve(org.apache.commons.math.linear.MatrixUtils.createRealIdentityMatrix(lTData.length));
		}
	}
}
2019-04-12 11:20:38,895 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:20:38,895 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc) {
						outBlock[(k++)] = tBlock[l];
					}
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:20:38,938 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:20:48,594 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:20:48,594 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:20:48,615 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:28:47,752 INFO main - The Process that runs JUnit test cases had problems: process hasn't exited
2019-04-12 11:29:11,041 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:29:11,041 ERROR main - Undo Error: original: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0) {
					res.append(",");
				}
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:29:11,046 ERROR main - Undo Error: modified: 
public abstract class AbstractRealMatrix implements org.apache.commons.math.linear.RealMatrix {
	@java.lang.Deprecated
	private org.apache.commons.math.linear.DecompositionSolver lu;

	protected AbstractRealMatrix() {
		lu = null;
	}

	protected AbstractRealMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		if (rowDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid row dimension {0} (must be positive)", rowDimension);
		}
		if (columnDimension <= 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("invalid column dimension {0} (must be positive)", columnDimension);
		}
		lu = null;
	}

	public abstract org.apache.commons.math.linear.RealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException;

	public abstract org.apache.commons.math.linear.RealMatrix copy();

	public org.apache.commons.math.linear.RealMatrix add(org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) - (m.getEntry(row, col))));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarAdd(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) + d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) {
		final int rowCount = getRowDimension();
		final int columnCount = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(rowCount, columnCount);
		for (int row = 0; row < rowCount; ++row) {
			for (int col = 0; col < columnCount; ++col) {
				out.setEntry(row, col, ((getEntry(row, col)) * d));
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final int nRows = getRowDimension();
		final int nCols = m.getColumnDimension();
		final int nSum = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, nCols);
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nSum; ++i) {
					sum += (getEntry(row, i)) * (m.getEntry(i, col));
				}
				out.setEntry(row, col, sum);
			}
		}
		return out;
	}

	public org.apache.commons.math.linear.RealMatrix preMultiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		return m.multiply(this);
	}

	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		for (int i = 0; i < (data.length); ++i) {
			final double[] dataI = data[i];
			for (int j = 0; j < (dataI.length); ++j) {
				dataI[j] = getEntry(i, j);
			}
		}
		return data;
	}

	public double getNorm() {
		return walkInColumnOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double endRow;

			private double columnSum;

			private double maxColSum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.endRow = endRow;
				columnSum = 0;
				maxColSum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				columnSum += java.lang.Math.abs(value);
				if (row == (endRow)) {
					maxColSum = java.lang.Math.max(maxColSum, columnSum);
					columnSum = 0;
				}
			}

			public double end() {
				return maxColSum;
			}
		});
	}

	public double getFrobeniusNorm() {
		return walkInOptimizedOrder(new org.apache.commons.math.linear.RealMatrixPreservingVisitor() {
			private double sum;

			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				sum = 0;
			}

			public void visit(final int row, final int column, final double value) {
				sum += value * value;
			}

			public double end() {
				return java.lang.Math.sqrt(sum);
			}
		});
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		for (int i = startRow; i <= endRow; ++i) {
			for (int j = startColumn; j <= endColumn; ++j) {
				subMatrix.setEntry((i - startRow), (j - startColumn), getEntry(i, j));
			}
		}
		return subMatrix;
	}

	public org.apache.commons.math.linear.RealMatrix getSubMatrix(final int[] selectedRows, final int[] selectedColumns) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		final org.apache.commons.math.linear.RealMatrix subMatrix = createMatrix(selectedRows.length, selectedColumns.length);
		subMatrix.walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixChangingVisitor() {
			@java.lang.Override
			public double visit(final int row, final int column, final double value) {
				return getEntry(selectedRows[row], selectedColumns[column]);
			}
		});
		return subMatrix;
	}

	public void copySubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn, final double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final int rowsCount = (endRow + 1) - startRow;
		final int columnsCount = (endColumn + 1) - startColumn;
		if (((destination.length) < rowsCount) || ((destination[0].length) < columnsCount)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, rowsCount, columnsCount);
		}
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			private int startRow;

			private int startColumn;

			@java.lang.Override
			public void start(final int rows, final int columns, final int startRow, final int endRow, final int startColumn, final int endColumn) {
				this.startRow = startRow;
				this.startColumn = startColumn;
			}

			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				destination[(row - (startRow))][(column - (startColumn))] = value;
			}
		}, startRow, endRow, startColumn, endColumn);
	}

	public void copySubMatrix(int[] selectedRows, int[] selectedColumns, double[][] destination) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, selectedRows, selectedColumns);
		if (((destination.length) < (selectedRows.length)) || ((destination[0].length) < (selectedColumns.length))) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", destination.length, destination[0].length, selectedRows.length, selectedColumns.length);
		}
		for (int i = 0; i < (selectedRows.length); i++) {
			final double[] destinationI = destination[i];
			for (int j = 0; j < (selectedColumns.length); j++) {
				destinationI[j] = getEntry(selectedRows[i], selectedColumns[j]);
			}
		}
	}

	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int nRows = subMatrix.length;
		if (nRows == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one row");
		}
		final int nCols = subMatrix[0].length;
		if (nCols == 0) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		for (int r = 1; r < nRows; ++r) {
			if ((subMatrix[r].length) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", nCols, subMatrix[r].length);
			}
		}
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, ((nRows + row) - 1));
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, ((nCols + column) - 1));
		for (int i = 0; i < nRows; ++i) {
			for (int j = 0; j < nCols; ++j) {
				setEntry((row + i), (column + j), subMatrix[i][j]);
			}
		}
		lu = null;
	}

	public org.apache.commons.math.linear.RealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(1, nCols);
		for (int i = 0; i < nCols; ++i) {
			out.setEntry(0, i, getEntry(row, i));
		}
		return out;
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, matrix.getEntry(0, i));
		}
	}

	public org.apache.commons.math.linear.RealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nRows, 1);
		for (int i = 0; i < nRows; ++i) {
			out.setEntry(i, 0, getEntry(i, column));
		}
		return out;
	}

	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, matrix.getEntry(i, 0));
		}
	}

	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getRow(row), false);
	}

	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((vector.getDimension()) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, vector.getDimension(), 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, vector.getEntry(i));
		}
	}

	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		return new org.apache.commons.math.linear.RealVectorImpl(getColumn(column), false);
	}

	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((vector.getDimension()) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", vector.getDimension(), 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, vector.getEntry(i));
		}
	}

	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		final double[] out = new double[nCols];
		for (int i = 0; i < nCols; ++i) {
			out[i] = getEntry(row, i);
		}
		return out;
	}

	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		for (int i = 0; i < nCols; ++i) {
			setEntry(row, i, array[i]);
		}
	}

	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		final double[] out = new double[nRows];
		for (int i = 0; i < nRows; ++i) {
			out[i] = getEntry(i, column);
		}
		return out;
	}

	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		for (int i = 0; i < nRows; ++i) {
			setEntry(i, column, array[i]);
		}
	}

	public abstract double getEntry(int row, int column) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void setEntry(int row, int column, double value) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void addToEntry(int row, int column, double increment) throws org.apache.commons.math.linear.MatrixIndexException;

	public abstract void multiplyEntry(int row, int column, double factor) throws org.apache.commons.math.linear.MatrixIndexException;

	public org.apache.commons.math.linear.RealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.RealMatrix out = createMatrix(nCols, nRows);
		walkInOptimizedOrder(new org.apache.commons.math.linear.DefaultRealMatrixPreservingVisitor() {
			@java.lang.Override
			public void visit(final int row, final int column, final double value) {
				out.setEntry(column, row, value);
			}
		});
		return out;
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix inverse() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.getInverse();
	}

	@java.lang.Deprecated
	public double getDeterminant() throws org.apache.commons.math.linear.InvalidMatrixException {
		return new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getDeterminant();
	}

	public boolean isSquare() {
		return (getColumnDimension()) == (getRowDimension());
	}

	@java.lang.Deprecated
	public boolean isSingular() {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return !(lu.isNonSingular());
	}

	public abstract int getRowDimension();

	public abstract int getColumnDimension();

	public double getTrace() throws org.apache.commons.math.linear.NonSquareMatrixException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (nRows != nCols) {
			throw new org.apache.commons.math.linear.NonSquareMatrixException(nRows, nCols);
		}
		double trace = 0;
		for (int i = 0; i < nRows; ++i) {
			trace += getEntry(i, i);
		}
		return trace;
	}

	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nCols) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nCols);
		}
		final double[] out = new double[nRows];
		for (int row = 0; row < nRows; ++row) {
			double sum = 0;
			for (int i = 0; i < nCols; ++i) {
				sum += (getEntry(row, i)) * (v[i]);
			}
			out[row] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector operate(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(operate(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nCols) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nCols);
			}
			final double[] out = new double[nRows];
			for (int row = 0; row < nRows; ++row) {
				double sum = 0;
				for (int i = 0; i < nCols; ++i) {
					sum += (getEntry(row, i)) * (v.getEntry(i));
				}
				out[row] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out, false);
		}
	}

	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if ((v.length) != nRows) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, nRows);
		}
		final double[] out = new double[nCols];
		for (int col = 0; col < nCols; ++col) {
			double sum = 0;
			for (int i = 0; i < nRows; ++i) {
				sum += (getEntry(i, col)) * (v[i]);
			}
			out[col] = sum;
		}
		return out;
	}

	public org.apache.commons.math.linear.RealVector preMultiply(final org.apache.commons.math.linear.RealVector v) throws java.lang.IllegalArgumentException {
		try {
			return new org.apache.commons.math.linear.RealVectorImpl(preMultiply(((org.apache.commons.math.linear.RealVectorImpl) (v)).getDataRef()), false);
		} catch (java.lang.ClassCastException cce) {
			final int nRows = getRowDimension();
			final int nCols = getColumnDimension();
			if ((v.getDimension()) != nRows) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.getDimension(), nRows);
			}
			final double[] out = new double[nCols];
			for (int col = 0; col < nCols; ++col) {
				double sum = 0;
				for (int i = 0; i < nRows; ++i) {
					sum += (getEntry(i, col)) * (v.getEntry(i));
				}
				out[col] = sum;
			}
			return new org.apache.commons.math.linear.RealVectorImpl(out);
		}
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int row = 0; row < rows; ++row) {
			for (int column = 0; column < columns; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int row = startRow; row <= endRow; ++row) {
			for (int column = startColumn; column <= endColumn; ++column) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		final int rows = getRowDimension();
		final int columns = getColumnDimension();
		visitor.start(rows, columns, 0, (rows - 1), 0, (columns - 1));
		for (int column = 0; column < columns; ++column) {
			for (int row = 0; row < rows; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				final double oldValue = getEntry(row, column);
				final double newValue = visitor.visit(row, column, oldValue);
				setEntry(row, column, newValue);
			}
		}
		lu = null;
		return visitor.end();
	}

	public double walkInColumnOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(getRowDimension(), getColumnDimension(), startRow, endRow, startColumn, endColumn);
		for (int column = startColumn; column <= endColumn; ++column) {
			for (int row = startRow; row <= endRow; ++row) {
				visitor.visit(row, column, getEntry(row, column));
			}
		}
		return visitor.end();
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		return walkInRowOrder(visitor, startRow, endRow, startColumn, endColumn);
	}

	@java.lang.Deprecated
	public double[] solve(final double[] b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public org.apache.commons.math.linear.RealMatrix solve(final org.apache.commons.math.linear.RealMatrix b) throws java.lang.IllegalArgumentException, org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
		return lu.solve(b);
	}

	@java.lang.Deprecated
	public void luDecompose() throws org.apache.commons.math.linear.InvalidMatrixException {
		if ((lu) == null) {
			lu = new org.apache.commons.math.linear.LUDecompositionImpl(this, org.apache.commons.math.util.MathUtils.SAFE_MIN).getSolver();
		}
	}

	@java.lang.Override
	public java.lang.String toString() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final java.lang.StringBuffer res = new java.lang.StringBuffer();
		java.lang.String fullClassName = getClass().getName();
		java.lang.String shortClassName = fullClassName.substring(((fullClassName.lastIndexOf('.')) + 1));
		res.append(shortClassName).append("{");
		for (int i = 0; i < nRows; ++i) {
			if (i > 0)
				res.append(",");
			
			res.append("{");
			for (int j = 0; j < nCols; ++j) {
				if (j > 0)
					res.append(",");
				
				res.append(getEntry(i, j));
			}
			res.append("}");
		}
		res.append("}");
		return res.toString();
	}

	@java.lang.Override
	public boolean equals(final java.lang.Object object) {
		if (object == (this)) {
			return true;
		}
		if ((object instanceof org.apache.commons.math.linear.RealMatrix) == false) {
			return false;
		}
		org.apache.commons.math.linear.RealMatrix m = ((org.apache.commons.math.linear.RealMatrix) (object));
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		if (((m.getColumnDimension()) != nCols) || ((m.getRowDimension()) != nRows)) {
			return false;
		}
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				if ((getEntry(row, col)) != (m.getEntry(row, col))) {
					return false;
				}
			}
		}
		return true;
	}

	@java.lang.Override
	public int hashCode() {
		int ret = 7;
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		ret = (ret * 31) + nRows;
		ret = (ret * 31) + nCols;
		for (int row = 0; row < nRows; ++row) {
			for (int col = 0; col < nCols; ++col) {
				ret = (ret * 31) + (((11 * (row + 1)) + (17 * (col + 1))) * (org.apache.commons.math.util.MathUtils.hash(getEntry(row, col))));
			}
		}
		return ret;
	}
}
2019-04-12 11:29:19,958 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:29:19,958 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock) {
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:29:19,991 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try 
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		 catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:32:17,368 ERROR main - Error: the model was not the same from the original after this generation
2019-04-12 11:32:17,368 ERROR main - Undo Error: original: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth) {
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				}
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:32:17,415 ERROR main - Undo Error: modified: 
public class DenseRealMatrix extends org.apache.commons.math.linear.AbstractRealMatrix implements java.io.Serializable {
	private static final long serialVersionUID = 4991895511313664478L;

	public static final int BLOCK_SIZE = 52;

	private final double[][] blocks;

	private final int rows;

	private final int columns;

	private final int blockRows;

	private final int blockColumns;

	public DenseRealMatrix(final int rows, final int columns) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blocks = org.apache.commons.math.linear.DenseRealMatrix.createBlocksLayout(rows, columns);
	}

	public DenseRealMatrix(final double[][] rawData) throws java.lang.IllegalArgumentException {
		this(rawData.length, rawData[0].length, org.apache.commons.math.linear.DenseRealMatrix.toBlocksLayout(rawData), false);
	}

	public DenseRealMatrix(final int rows, final int columns, final double[][] blockData, final boolean copyArray) throws java.lang.IllegalArgumentException {
		super(rows, columns);
		this.rows = rows;
		this.columns = columns;
		blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		if (copyArray) {
			blocks = new double[(blockRows) * (blockColumns)][];
		}else {
			blocks = blockData;
		}
		int index = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++index) {
				if ((blockData[index].length) != (iHeight * (blockWidth(jBlock)))) {
					throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("wrong array shape (block length = {0}, expected {1})", blockData[index].length, (iHeight * (blockWidth(jBlock))));
				}
				if (copyArray) {
					blocks[index] = blockData[index].clone();
				}
			}
		}
	}

	public static double[][] toBlocksLayout(final double[][] rawData) throws java.lang.IllegalArgumentException {
		final int rows = rawData.length;
		final int columns = rawData[0].length;
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int i = 0; i < (rawData.length); ++i) {
			final int length = rawData[i].length;
			if (length != columns) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", columns, length);
			}
		}
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				final double[] block = new double[iHeight * jWidth];
				blocks[blockIndex] = block;
				for (int p = pStart, index = 0; p < pEnd; ++p , index += jWidth)
					java.lang.System.arraycopy(rawData[p], qStart, block, index, jWidth);
				
			}
		}
		return blocks;
	}

	public static double[][] createBlocksLayout(final int rows, final int columns) {
		final int blockRows = ((rows + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockColumns = ((columns + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) - 1) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final double[][] blocks = new double[blockRows * blockColumns][];
		for (int iBlock = 0, blockIndex = 0; iBlock < blockRows; ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			final int iHeight = pEnd - pStart;
			for (int jBlock = 0; jBlock < blockColumns; ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int jWidth = qEnd - qStart;
				blocks[blockIndex] = new double[iHeight * jWidth];
			}
		}
		return blocks;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix createMatrix(final int rowDimension, final int columnDimension) throws java.lang.IllegalArgumentException {
		return new org.apache.commons.math.linear.DenseRealMatrix(rowDimension, columnDimension);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix copy() {
		org.apache.commons.math.linear.DenseRealMatrix copied = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int i = 0; i < (blocks.length); ++i) {
			java.lang.System.arraycopy(blocks[i], 0, copied.blocks[i], 0, blocks[i].length);
		}
		return copied;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return add(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) + (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix add(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkAdditionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return subtract(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final double[] outBlock = out.blocks[blockIndex];
					final double[] tBlock = blocks[blockIndex];
					final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						for (int q = qStart; q < qEnd; ++q , ++k) {
							outBlock[k] = (tBlock[k]) - (m.getEntry(p, q));
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix subtract(final org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkSubtractionCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			final double[] mBlock = m.blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) - (mBlock[k]);
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix scalarAdd(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) + d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealMatrix scalarMultiply(final double d) throws java.lang.IllegalArgumentException {
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, columns);
		for (int blockIndex = 0; blockIndex < (out.blocks.length); ++blockIndex) {
			final double[] outBlock = out.blocks[blockIndex];
			final double[] tBlock = blocks[blockIndex];
			for (int k = 0; k < (outBlock.length); ++k) {
				outBlock[k] = (tBlock[k]) * d;
			}
		}
		return out;
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix multiply(final org.apache.commons.math.linear.RealMatrix m) throws java.lang.IllegalArgumentException {
		try {
			return multiply(((org.apache.commons.math.linear.DenseRealMatrix) (m)));
		} catch (java.lang.ClassCastException cce) {
			org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
			final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.getColumnDimension());
			int blockIndex = 0;
			for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), m.getColumnDimension());
					final double[] outBlock = out.blocks[blockIndex];
					for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
						final int kWidth = blockWidth(kBlock);
						final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
						final int rStart = kBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
						for (int p = pStart, k = 0; p < pEnd; ++p) {
							final int lStart = (p - pStart) * kWidth;
							final int lEnd = lStart + kWidth;
							for (int q = qStart; q < qEnd; ++q) {
								double sum = 0;
								for (int l = lStart, r = rStart; l < lEnd; ++l , ++r) {
									sum += (tBlock[l]) * (m.getEntry(r, q));
								}
								outBlock[(k++)] += sum;
							}
						}
					}
					++blockIndex;
				}
			}
			return out;
		}
	}

	public org.apache.commons.math.linear.DenseRealMatrix multiply(org.apache.commons.math.linear.DenseRealMatrix m) throws java.lang.IllegalArgumentException {
		org.apache.commons.math.linear.MatrixUtils.checkMultiplicationCompatible(this, m);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, m.columns);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (out.blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (out.blockColumns); ++jBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int jWidth2 = jWidth + jWidth;
				final int jWidth3 = jWidth2 + jWidth;
				final int jWidth4 = jWidth3 + jWidth;
				final double[] outBlock = out.blocks[blockIndex];
				for (int kBlock = 0; kBlock < (blockColumns); ++kBlock) {
					final int kWidth = blockWidth(kBlock);
					final double[] tBlock = blocks[((iBlock * (blockColumns)) + kBlock)];
					final double[] mBlock = m.blocks[((kBlock * (m.blockColumns)) + jBlock)];
					for (int p = pStart, k = 0; p < pEnd; ++p) {
						final int lStart = (p - pStart) * kWidth;
						final int lEnd = lStart + kWidth;
						for (int nStart = 0; nStart < jWidth; ++nStart) {
							double sum = 0;
							int l = lStart;
							int n = nStart;
							while (l < (lEnd - 3)) {
								sum += ((((tBlock[l]) * (mBlock[n])) + ((tBlock[(l + 1)]) * (mBlock[(n + jWidth)]))) + ((tBlock[(l + 2)]) * (mBlock[(n + jWidth2)]))) + ((tBlock[(l + 3)]) * (mBlock[(n + jWidth3)]));
								l += 4;
								n += jWidth4;
							} 
							while (l < lEnd) {
								sum += (tBlock[(l++)]) * (mBlock[n]);
								n += jWidth;
							} 
							outBlock[(k++)] += sum;
						}
					}
				}
				++blockIndex;
			}
		}
		return out;
	}

	@java.lang.Override
	public double[][] getData() {
		final double[][] data = new double[getRowDimension()][getColumnDimension()];
		final int lastColumns = (columns) - (((blockColumns) - 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			int regularPos = 0;
			int lastPos = 0;
			for (int p = pStart; p < pEnd; ++p) {
				final double[] dataP = data[p];
				int blockIndex = iBlock * (blockColumns);
				int dataPos = 0;
				for (int jBlock = 0; jBlock < ((blockColumns) - 1); ++jBlock) {
					java.lang.System.arraycopy(blocks[(blockIndex++)], regularPos, dataP, dataPos, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					dataPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				}
				java.lang.System.arraycopy(blocks[blockIndex], lastPos, dataP, dataPos, lastColumns);
				regularPos += org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
				lastPos += lastColumns;
			}
		}
		return data;
	}

	@java.lang.Override
	public double getNorm() {
		final double[] colSums = new double[org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE];
		double maxColSum = 0;
		for (int jBlock = 0; jBlock < (blockColumns); jBlock++) {
			final int jWidth = blockWidth(jBlock);
			java.util.Arrays.fill(colSums, 0, jWidth, 0.0);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final int iHeight = blockHeight(iBlock);
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int j = 0; j < jWidth; ++j) {
					double sum = 0;
					for (int i = 0; i < iHeight; ++i) {
						sum += java.lang.Math.abs(block[((i * jWidth) + j)]);
					}
					colSums[j] += sum;
				}
			}
			for (int j = 0; j < jWidth; ++j) {
				maxColSum = java.lang.Math.max(maxColSum, colSums[j]);
			}
		}
		return maxColSum;
	}

	@java.lang.Override
	public double getFrobeniusNorm() {
		double sum2 = 0;
		for (int blockIndex = 0; blockIndex < (blocks.length); ++blockIndex) {
			for (final double entry : blocks[blockIndex]) {
				sum2 += entry * entry;
			}
		}
		return java.lang.Math.sqrt(sum2);
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getSubMatrix(final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(((endRow - startRow) + 1), ((endColumn - startColumn) + 1));
		final int blockStartRow = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int rowsShift = startRow % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int columnsShift = startColumn % (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = 0, pBlock = blockStartRow; iBlock < (out.blockRows); ++iBlock , ++pBlock) {
			final int iHeight = out.blockHeight(iBlock);
			for (int jBlock = 0, qBlock = blockStartColumn; jBlock < (out.blockColumns); ++jBlock , ++qBlock) {
				final int jWidth = out.blockWidth(jBlock);
				final int outIndex = (iBlock * (out.blockColumns)) + jBlock;
				final double[] outBlock = out.blocks[outIndex];
				final int index = (pBlock * (blockColumns)) + qBlock;
				final int width = blockWidth(qBlock);
				final int heightExcess = (iHeight + rowsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int widthExcess = (jWidth + columnsShift) - (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				if (heightExcess > 0) {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, (iHeight - heightExcess), 0);
						copyBlockPart(blocks[((index + (blockColumns)) + 1)], width2, 0, heightExcess, 0, widthExcess, outBlock, jWidth, (iHeight - heightExcess), (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + (blockColumns))], width, 0, heightExcess, columnsShift, (jWidth + columnsShift), outBlock, jWidth, (iHeight - heightExcess), 0);
					}
				}else {
					if (widthExcess > 0) {
						final int width2 = blockWidth((qBlock + 1));
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE, outBlock, jWidth, 0, 0);
						copyBlockPart(blocks[(index + 1)], width2, rowsShift, (iHeight + rowsShift), 0, widthExcess, outBlock, jWidth, 0, (jWidth - widthExcess));
					}else {
						copyBlockPart(blocks[index], width, rowsShift, (iHeight + rowsShift), columnsShift, (jWidth + columnsShift), outBlock, jWidth, 0, 0);
					}
				}
			}
		}
		return out;
	}

	private void copyBlockPart(final double[] srcBlock, final int srcWidth, final int srcStartRow, final int srcEndRow, final int srcStartColumn, final int srcEndColumn, final double[] dstBlock, final int dstWidth, final int dstStartRow, final int dstStartColumn) {
		final int length = srcEndColumn - srcStartColumn;
		int srcPos = (srcStartRow * srcWidth) + srcStartColumn;
		int dstPos = (dstStartRow * dstWidth) + dstStartColumn;
		for (int srcRow = srcStartRow; srcRow < srcEndRow; ++srcRow) {
			java.lang.System.arraycopy(srcBlock, srcPos, dstBlock, dstPos, length);
			srcPos += srcWidth;
			dstPos += dstWidth;
		}
	}

	@java.lang.Override
	public void setSubMatrix(final double[][] subMatrix, final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		final int refLength = subMatrix[0].length;
		if (refLength < 1) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("matrix must have at least one column");
		}
		final int endRow = (row + (subMatrix.length)) - 1;
		final int endColumn = (column + refLength) - 1;
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, row, endRow, column, endColumn);
		for (final double[] subRow : subMatrix) {
			if ((subRow.length) != refLength) {
				throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("some rows have length {0} while others have length {1}", refLength, subRow.length);
			}
		}
		final int blockStartRow = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndRow = (endRow + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockStartColumn = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int blockEndColumn = (endColumn + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		for (int iBlock = blockStartRow; iBlock < blockEndRow; ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final int firstRow = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int iStart = java.lang.Math.max(row, firstRow);
			final int iEnd = java.lang.Math.min((endRow + 1), (firstRow + iHeight));
			for (int jBlock = blockStartColumn; jBlock < blockEndColumn; ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int firstColumn = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int jStart = java.lang.Math.max(column, firstColumn);
				final int jEnd = java.lang.Math.min((endColumn + 1), (firstColumn + jWidth));
				final int jLength = jEnd - jStart;
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int i = iStart; i < iEnd; ++i) {
					java.lang.System.arraycopy(subMatrix[(i - row)], (jStart - column), block, (((i - firstRow) * jWidth) + (jStart - firstColumn)), jLength);
				}
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getRowMatrix(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(1, columns);
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (outBlock.length) - outIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, available);
				outBlock = out.blocks[(++outBlockIndex)];
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, 0, (jWidth - available));
				outIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(block, (iRow * jWidth), outBlock, outIndex, jWidth);
				outIndex += jWidth;
			}
		}
		return out;
	}

	@java.lang.Override
	public void setRowMatrix(final int row, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRowMatrix(row, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setRowMatrix(row, matrix);
		}
	}

	public void setRowMatrix(final int row, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if (((matrix.getRowDimension()) != 1) || ((matrix.getColumnDimension()) != nCols)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			final int available = (mBlock.length) - mIndex;
			if (jWidth > available) {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), available);
				mBlock = matrix.blocks[(++mBlockIndex)];
				java.lang.System.arraycopy(mBlock, 0, block, (iRow * jWidth), (jWidth - available));
				mIndex = jWidth - available;
			}else {
				java.lang.System.arraycopy(mBlock, mIndex, block, (iRow * jWidth), jWidth);
				mIndex += jWidth;
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix getColumnMatrix(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(rows, 1);
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outBlockIndex = 0;
		int outIndex = 0;
		double[] outBlock = out.blocks[outBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (outIndex >= (outBlock.length)) {
					outBlock = out.blocks[(++outBlockIndex)];
					outIndex = 0;
				}
				outBlock[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumnMatrix(final int column, final org.apache.commons.math.linear.RealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumnMatrix(column, ((org.apache.commons.math.linear.DenseRealMatrix) (matrix)));
		} catch (java.lang.ClassCastException cce) {
			super.setColumnMatrix(column, matrix);
		}
	}

	void setColumnMatrix(final int column, final org.apache.commons.math.linear.DenseRealMatrix matrix) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if (((matrix.getRowDimension()) != nRows) || ((matrix.getColumnDimension()) != 1)) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", matrix.getRowDimension(), matrix.getColumnDimension(), nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int mBlockIndex = 0;
		int mIndex = 0;
		double[] mBlock = matrix.blocks[mBlockIndex];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				if (mIndex >= (mBlock.length)) {
					mBlock = matrix.blocks[(++mBlockIndex)];
					mIndex = 0;
				}
				block[((i * jWidth) + jColumn)] = mBlock[(mIndex++)];
			}
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getRowVector(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] outData = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), outData, outIndex, jWidth);
			outIndex += jWidth;
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setRowVector(final int row, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setRow(row, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setRowVector(row, vector);
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.RealVector getColumnVector(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] outData = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				outData[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return new org.apache.commons.math.linear.RealVectorImpl(outData, false);
	}

	@java.lang.Override
	public void setColumnVector(final int column, final org.apache.commons.math.linear.RealVector vector) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		try {
			setColumn(column, ((org.apache.commons.math.linear.RealVectorImpl) (vector)).getDataRef());
		} catch (java.lang.ClassCastException cce) {
			super.setColumnVector(column, vector);
		}
	}

	@java.lang.Override
	public double[] getRow(final int row) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final double[] out = new double[columns];
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(block, (iRow * jWidth), out, outIndex, jWidth);
			outIndex += jWidth;
		}
		return out;
	}

	@java.lang.Override
	public void setRow(final int row, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkRowIndex(this, row);
		final int nCols = getColumnDimension();
		if ((array.length) != nCols) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", 1, array.length, 1, nCols);
		}
		final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int iRow = row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		int outIndex = 0;
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			java.lang.System.arraycopy(array, outIndex, block, (iRow * jWidth), jWidth);
			outIndex += jWidth;
		}
	}

	@java.lang.Override
	public double[] getColumn(final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final double[] out = new double[rows];
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				out[(outIndex++)] = block[((i * jWidth) + jColumn)];
			}
		}
		return out;
	}

	@java.lang.Override
	public void setColumn(final int column, final double[] array) throws org.apache.commons.math.linear.InvalidMatrixException, org.apache.commons.math.linear.MatrixIndexException {
		org.apache.commons.math.linear.MatrixUtils.checkColumnIndex(this, column);
		final int nRows = getRowDimension();
		if ((array.length) != nRows) {
			throw new org.apache.commons.math.linear.InvalidMatrixException("dimensions mismatch: got {0}x{1} but expected {2}x{3}", array.length, 1, nRows, 1);
		}
		final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
		final int jColumn = column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE));
		final int jWidth = blockWidth(jBlock);
		int outIndex = 0;
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int iHeight = blockHeight(iBlock);
			final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
			for (int i = 0; i < iHeight; ++i) {
				block[((i * jWidth) + jColumn)] = array[(outIndex++)];
			}
		}
	}

	@java.lang.Override
	public double getEntry(final int row, final int column) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			return blocks[((iBlock * (blockColumns)) + jBlock)][k];
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void setEntry(final int row, final int column, final double value) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] = value;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void addToEntry(final int row, final int column, final double increment) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] += increment;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public void multiplyEntry(final int row, final int column, final double factor) throws org.apache.commons.math.linear.MatrixIndexException {
		try {
			final int iBlock = row / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int jBlock = column / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int k = ((row - (iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))) * (blockWidth(jBlock))) + (column - (jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)));
			blocks[((iBlock * (blockColumns)) + jBlock)][k] *= factor;
		} catch (java.lang.ArrayIndexOutOfBoundsException e) {
			throw new org.apache.commons.math.linear.MatrixIndexException("no entry at indices ({0}, {1}) in a {2}x{3} matrix", row, column, getRowDimension(), getColumnDimension());
		}
	}

	@java.lang.Override
	public org.apache.commons.math.linear.DenseRealMatrix transpose() {
		final int nRows = getRowDimension();
		final int nCols = getColumnDimension();
		final org.apache.commons.math.linear.DenseRealMatrix out = new org.apache.commons.math.linear.DenseRealMatrix(nCols, nRows);
		int blockIndex = 0;
		for (int iBlock = 0; iBlock < (blockColumns); ++iBlock)
			for (int jBlock = 0; jBlock < (blockRows); ++jBlock) {
				final double[] outBlock = out.blocks[blockIndex];
				final double[] tBlock = blocks[((jBlock * (blockColumns)) + iBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					final int lInc = pEnd - pStart;
					for (int q = qStart, l = p - pStart; q < qEnd; ++q , l += lInc)
						outBlock[(k++)] = tBlock[l];
					
				}
				++blockIndex;
			}
		
		return out;
	}

	@java.lang.Override
	public int getRowDimension() {
		return rows;
	}

	@java.lang.Override
	public int getColumnDimension() {
		return columns;
	}

	@java.lang.Override
	public double[] operate(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (columns)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, columns);
		}
		final double[] out = new double[rows];
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					double sum = 0;
					int q = qStart;
					while (q < (qEnd - 3)) {
						sum += ((((block[k]) * (v[q])) + ((block[(k + 1)]) * (v[(q + 1)]))) + ((block[(k + 2)]) * (v[(q + 2)]))) + ((block[(k + 3)]) * (v[(q + 3)]));
						k += 4;
						q += 4;
					} 
					while (q < qEnd) {
						sum += (block[(k++)]) * (v[(q++)]);
					} 
					out[p] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double[] preMultiply(final double[] v) throws java.lang.IllegalArgumentException {
		if ((v.length) != (rows)) {
			throw org.apache.commons.math.MathRuntimeException.createIllegalArgumentException("vector length mismatch: got {0} but expected {1}", v.length, rows);
		}
		final double[] out = new double[columns];
		for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
			final int jWidth = blockWidth(jBlock);
			final int jWidth2 = jWidth + jWidth;
			final int jWidth3 = jWidth2 + jWidth;
			final int jWidth4 = jWidth3 + jWidth;
			final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
			for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
				for (int q = qStart; q < qEnd; ++q) {
					int k = q - qStart;
					double sum = 0;
					int p = pStart;
					while (p < (pEnd - 3)) {
						sum += ((((block[k]) * (v[p])) + ((block[(k + jWidth)]) * (v[(p + 1)]))) + ((block[(k + jWidth2)]) * (v[(p + 2)]))) + ((block[(k + jWidth3)]) * (v[(p + 3)]));
						k += jWidth4;
						p += 4;
					} 
					while (p < pEnd) {
						sum += (block[k]) * (v[(p++)]);
						k += jWidth;
					} 
					out[q] += sum;
				}
			}
		}
		return out;
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = 0; jBlock < (blockColumns); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (p - pStart) * jWidth; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInRowOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int p = pStart; p < pEnd; ++p) {
				for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
					final int jWidth = blockWidth(jBlock);
					final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
					final int qStart = java.lang.Math.max(startColumn, q0);
					final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
					final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor) throws org.apache.commons.math.linear.MatrixVisitorException {
		visitor.start(rows, columns, 0, ((rows) - 1), 0, ((columns) - 1));
		for (int iBlock = 0, blockIndex = 0; iBlock < (blockRows); ++iBlock) {
			final int pStart = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pEnd = java.lang.Math.min((pStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), rows);
			for (int jBlock = 0; jBlock < (blockColumns); ++jBlock , ++blockIndex) {
				final int qStart = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qEnd = java.lang.Math.min((qStart + (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), columns);
				final double[] block = blocks[blockIndex];
				for (int p = pStart, k = 0; p < pEnd; ++p) {
					for (int q = qStart; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixChangingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						block[k] = visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	@java.lang.Override
	public double walkInOptimizedOrder(final org.apache.commons.math.linear.RealMatrixPreservingVisitor visitor, final int startRow, final int endRow, final int startColumn, final int endColumn) throws org.apache.commons.math.linear.MatrixIndexException, org.apache.commons.math.linear.MatrixVisitorException {
		org.apache.commons.math.linear.MatrixUtils.checkSubMatrixIndex(this, startRow, endRow, startColumn, endColumn);
		visitor.start(rows, columns, startRow, endRow, startColumn, endColumn);
		for (int iBlock = startRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); iBlock < (1 + (endRow / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++iBlock) {
			final int p0 = iBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
			final int pStart = java.lang.Math.max(startRow, p0);
			final int pEnd = java.lang.Math.min(((iBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endRow));
			for (int jBlock = startColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE); jBlock < (1 + (endColumn / (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE))); ++jBlock) {
				final int jWidth = blockWidth(jBlock);
				final int q0 = jBlock * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE);
				final int qStart = java.lang.Math.max(startColumn, q0);
				final int qEnd = java.lang.Math.min(((jBlock + 1) * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)), (1 + endColumn));
				final double[] block = blocks[((iBlock * (blockColumns)) + jBlock)];
				for (int p = pStart; p < pEnd; ++p) {
					for (int q = qStart, k = (((p - p0) * jWidth) + qStart) - q0; q < qEnd; ++q , ++k) {
						visitor.visit(p, q, block[k]);
					}
				}
			}
		}
		return visitor.end();
	}

	private int blockHeight(final int blockRow) {
		return blockRow == ((blockRows) - 1) ? (rows) - (blockRow * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}

	private int blockWidth(final int blockColumn) {
		return blockColumn == ((blockColumns) - 1) ? (columns) - (blockColumn * (org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE)) : org.apache.commons.math.linear.DenseRealMatrix.BLOCK_SIZE;
	}
}
2019-04-12 11:32:32,448 INFO main - Time Repair Loop (s): 1166.637
2019-04-12 11:32:32,448 INFO main - 
----SUMMARY_EXECUTION---
2019-04-12 11:32:32,448 INFO main - 
successful_ing_attempts (0): []
2019-04-12 11:32:32,449 INFO main - 
failing_ing_attempts (600): [7, 3, 2, 1, 3, 2, 3, 0, 0, 6, 4, 0, 15, 2, 5, 2, 0, 0, 2, 12, 7, 5, 6, 24, 0, 4, 1, 1, 3, 15, 9, 17, 8, 4, 3, 2, 0, 14, 3, 3, 0, 0, 4, 2, 14, 0, 0, 7, 1, 5, 0, 15, 2, 0, 2, 14, 1, 0, 1, 1, 29, 19, 11, 1, 4, 12, 3, 2, 9, 1, 2, 0, 2, 10, 0, 2, 36, 30, 5, 0, 0, 0, 0, 5, 0, 2, 19, 1, 5, 4, 0, 1, 4, 1, 5, 14, 2, 6, 11, 15, 8, 5, 3, 5, 0, 11, 2, 0, 3, 0, 28, 0, 2, 8, 3, 9, 2, 1, 1, 5, 0, 0, 0, 14, 1, 0, 6, 2, 2, 1, 7, 0, 1, 0, 1, 0, 2, 3, 0, 4, 5, 9, 16, 0, 0, 2, 4, 1, 7, 33, 4, 4, 4, 5, 0, 9, 3, 0, 0, 0, 0, 13, 21, 0, 7, 2, 0, 2, 8, 0, 0, 4, 0, 0, 3, 2, 5, 1, 15, 0, 3, 0, 16, 3, 1, 0, 0, 7, 0, 13, 0, 0, 3, 0, 1, 0, 0, 3, 0, 9, 3, 3, 3, 5, 0, 3, 10, 5, 0, 0, 3, 1, 2, 1, 8, 2, 0, 3, 2, 2, 2, 3, 2, 10, 3, 0, 12, 6, 9, 3, 13, 1, 0, 8, 3, 7, 0, 21, 3, 3, 0, 1, 3, 0, 0, 1, 8, 2, 3, 0, 0, 1, 0, 0, 16, 6, 0, 4, 4, 2, 1, 3, 11, 0, 13, 0, 14, 4, 0, 5, 3, 0, 1, 3, 1, 1, 2, 7, 2, 1, 1, 0, 8, 6, 23, 4, 8, 5, 5, 20, 3, 2, 0, 6, 0, 0, 4, 0, 0, 1, 0, 2, 0, 5, 7, 4, 6, 4, 0, 5, 3, 6, 4, 0, 6, 0, 3, 7, 3, 5, 0, 0, 12, 0, 3, 3, 1, 0, 8, 10, 3, 5, 1, 11, 2, 0, 1, 0, 18, 0, 0, 4, 2, 1, 1, 1, 15, 6, 5, 6, 2, 6, 11, 0, 5, 0, 0, 0, 21, 0, 20, 0, 5, 0, 0, 4, 1, 12, 5, 1, 2, 5, 6, 28, 3, 0, 2, 1, 19, 0, 14, 0, 2, 1, 6, 0, 14, 15, 17, 7, 6, 1, 0, 18, 18, 1, 7, 10, 7, 10, 8, 7, 20, 0, 0, 0, 0, 5, 0, 0, 3, 8, 5, 4, 0, 25, 6, 4, 12, 0, 24, 13, 15, 2, 2, 10, 1, 11, 4, 0, 0, 3, 1, 7, 1, 0, 9, 0, 2, 15, 5, 9, 10, 8, 3, 2, 1, 0, 0, 9, 5, 0, 15, 6, 1, 0, 1, 0, 16, 0, 9, 10, 4, 0, 2, 0, 0, 14, 10, 8, 0, 5, 0, 1, 2, 0, 5, 6, 2, 2, 0, 1, 4, 2, 8, 6, 8, 0, 0, 2, 5, 0, 4, 1, 2, 11, 11, 1, 0, 1, 0, 0, 8, 9, 68, 0, 2, 5, 10, 10, 4, 0, 6, 0, 3, 3, 13, 0, 1, 3, 15, 0, 4, 1, 0, 2, 7, 0, 0, 5, 28, 6, 0, 5, 0, 6, 0, 2, 2, 0, 3, 1, 0, 1, 0, 7, 6, 9, 2, 5, 6, 10, 4, 5, 15, 7, 3, 0, 6, 0, 4, 9, 2, 2, 14, 71, 11, 1, 0, 1, 0, 10, 4, 8, 1, 4, 1, 5, 1, 6, 3, 7, 0, 2, 2, 1, 2, 2, 15, 4, 11, 14, 1, 3, 9, 0, 13, 1, 1, 2]
2019-04-12 11:32:32,449 INFO fr.inria.main.evolution.AstorMain - Time Total(s): 1246.778
[DONE]
