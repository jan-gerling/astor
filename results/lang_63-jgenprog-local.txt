2019-04-13 19:18:47,717 INFO main - command line arguments: [-jvm4testexecution  /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin  -mode  jgenprog  -scope  local  -srcjavafolder  /src/java/  -srctestfolder  /src/test/  -binjavafolder  /target/classes/  -bintestfolder  /target/test-classes/  -location  test02/lang_63/  -dependencies  ./examples/libs/junit-4.4.jar  -flthreshold  0.5  -maxtime  100  -stopfirst  true]
2019-04-13 19:18:48,274 INFO main - -Executing Gzoltar classpath: /home/jan_gerling/astor/./outputMutation/AstorMain-lang_63//bin//default from 88 classes with test cases
2019-04-13 19:18:48,275 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar fault localization: min susp value parameter: 0.5
2019-04-13 19:18:48,915 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - -gz-Adding classpath: [/home/jan_gerling/astor/./examples/libs/junit-4.4.jar, /home/jan_gerling/astor/./outputMutation/AstorMain-lang_63//bin//default]
2019-04-13 19:19:01,471 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.lang.LocaleUtilsTest#testCountriesByLanguage
2019-04-13 19:19:01,473 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Test failt: org.apache.commons.lang.time.DurationFormatUtilsTest#testJiraLang281
2019-04-13 19:19:01,476 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar Test Result Total:1671, fails: 2, GZoltar suspicious 8484
2019-04-13 19:19:01,483 INFO fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization - Gzoltar found: 35 with susp > 0.5, we consider: 35
2019-04-13 19:19:01,491 INFO main - building model: /home/jan_gerling/astor/./outputMutation/AstorMain-lang_63//src//default, compliance level: 8
2019-04-13 19:19:04,328 ERROR main - Problem compiling the model with compliance level 8
2019-04-13 19:19:04,328 ERROR main - Syntax error on token "enum", Identifier expected at /home/jan_gerling/astor/outputMutation/AstorMain-lang_63/src/default/org/apache/commons/lang/enum/Enum.java:17
2019-04-13 19:19:04,328 INFO main - building model: /home/jan_gerling/astor/./outputMutation/AstorMain-lang_63//src//default, compliance level: 4
2019-04-13 19:19:08,223 INFO main - 
---- Initial suspicious size: 35
2019-04-13 19:19:08,275 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=277, susp=0.7071067811865475]
2019-04-13 19:19:08,277 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=278, susp=0.7071067811865475]
2019-04-13 19:19:08,286 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=283, susp=0.7071067811865475]
2019-04-13 19:19:08,405 INFO main - Total suspicious from FL: 35,  32
2019-04-13 19:19:08,405 INFO main - Total ModPoint created: 32
2019-04-13 19:19:08,405 INFO main - Creating program variant #1, [Variant id: 1, #gens: 32, #ops: 0, parent:-]
2019-04-13 19:19:08,596 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=277, susp=0.7071067811865475]
2019-04-13 19:19:08,599 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=278, susp=0.7071067811865475]
2019-04-13 19:19:08,607 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=283, susp=0.7071067811865475]
2019-04-13 19:19:08,666 INFO main - Total suspicious from FL: 35,  32
2019-04-13 19:19:08,666 INFO main - Total ModPoint created: 32
2019-04-13 19:19:08,666 INFO main - Creating program variant #2, [Variant id: 2, #gens: 32, #ops: 0, parent:-]
2019-04-13 19:19:08,683 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=277, susp=0.7071067811865475]
2019-04-13 19:19:08,685 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=278, susp=0.7071067811865475]
2019-04-13 19:19:08,689 INFO main - -any mod point created for suspicious Candidate [className=org.apache.commons.lang.LocaleUtils, methodName=org.apache.commons.lang.LocaleUtils{countriesByLanguage(Ljava/lang/String;)Ljava/util/List; 0.0, lineNumber=283, susp=0.7071067811865475]
2019-04-13 19:19:08,740 INFO main - Total suspicious from FL: 35,  32
2019-04-13 19:19:08,740 INFO main - Total ModPoint created: 32
2019-04-13 19:19:08,740 INFO main - Creating program variant #3, [Variant id: 3, #gens: 32, #ops: 0, parent:-]
2019-04-13 19:19:20,214 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - ---Configuration properties:---Execution values
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:faultlocalization= fr.inria.astor.core.faultlocalization.GZoltarFaultLocalization
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:packageToInstrument= 
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:flthreshold= 0.5
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:numberExecutions= 1
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuiteresultfolder= evosuite
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:compiler= fr.inria.astor.core.manipulation.bytecode.compiler.SpoonClassCompiler
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoredTestCases= 
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:skipfaultlocalization= false
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxGeneration= 200
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxsuspcandidates= 1000
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax2= 960000
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:tmax1= 120000
2019-04-13 19:19:20,215 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:workingDirectory= /home/jan_gerling/astor/./outputMutation
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mode= jgenprog
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:ignoreflakyinfl= false
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:uniqueoptogen= false
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pathToMVNRepository= 
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:timezone= America/Los_Angeles
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:applyCrossover= false
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clonegranularity= types
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:modificationpointnavigation= weight
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:clusteringfilename= clustering.csv
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:maxtime= 100
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:probagenmutation= false
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:alternativecompliancelevel= 4
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:version-location= ./math-version/
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:location= test02/lang_63/
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:filterfaultlocalization= true
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:stopfirst= true
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4testexecution= /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bugId= 280
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:mutationrate= 1 
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:forceExecuteRegression= false
2019-04-13 19:19:20,216 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:projectIdentifier= 
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_buggy_class= true
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoRunOnBuggyClass= true
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resetoperations= false
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:jvm4evosuitetestexecution= /usr/lib/jvm/java-1.7.0-openjdk-amd64/bin
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:seed= 0
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:testbystep= false
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srctestfolder= /src/test/
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:javacompliancelevel= 8
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:bintestfolder= /target/test-classes/
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:fitnessfunction= fr.inria.astor.core.loop.population.TestCaseFitnessFunction
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:commandTrunk= 50000
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:dependenciespath= ./examples/libs/junit-4.4.jar
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:multipointmodification= false
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:transformingredient= false
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:validation= process
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:scope= local
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitetimeout= 120
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evoDSE= false
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:elementsToMutate= 10
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:lastJUnitVersion= ./examples/libs/junit-4.11.jar
2019-04-13 19:19:20,217 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:allpoints= false
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:resourcesfolder= /src/main/resources:/src/test/resources:
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:regressionforfaultlocalization= true
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:population= 3
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:saveall= false
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:pvariantfoldername= variant-
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:populationcontroller= fr.inria.astor.core.loop.population.TestCaseBasedFitnessPopulationController
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:savesolution= true
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:srcjavafolder= /src/java/
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evo_affected_by_op= true
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:binjavafolder= /target/classes/
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:reintroduce= original-parents
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:evosuitejar= ./lib/evosuite-master-1.0.4-SNAPSHOT.jar
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - p:learningdir= 
2019-04-13 19:19:20,218 INFO fr.inria.astor.core.setup.ConfigurationProperties - ----------------------------
2019-04-13 19:19:20,218 INFO main - 
----Starting Solution Search
2019-04-13 19:19:22,288 ERROR main - Error: the model was not the same from the original after this generation
2019-04-13 19:19:22,288 ERROR main - Undo Error: original: 
public class DurationFormatUtils {
	public DurationFormatUtils() {
		super();
	}

	public static final java.lang.String ISO_EXTENDED_FORMAT_PATTERN = "'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'";

	public static java.lang.String formatDurationHMS(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "H:mm:ss.SSS");
	}

	public static java.lang.String formatDurationISO(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, format, true);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format, boolean padWithZeros) {
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		int days = 0;
		int hours = 0;
		int minutes = 0;
		int seconds = 0;
		int milliseconds = 0;
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d)) {
			days = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY)));
			durationMillis = durationMillis - (days * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H)) {
			hours = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR)));
			durationMillis = durationMillis - (hours * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m)) {
			minutes = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE)));
			durationMillis = durationMillis - (minutes * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s)) {
			seconds = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND)));
			durationMillis = durationMillis - (seconds * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.S)) {
			milliseconds = ((int) (durationMillis));
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	public static java.lang.String formatDurationWords(long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements) {
		java.lang.String duration = org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");
		if (suppressLeadingZeroElements) {
			duration = " " + duration;
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 days", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
					duration = tmp;
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 seconds", "");
					}
				}
			}
			if ((duration.length()) != 0) {
				duration = duration.substring(1);
			}
		}
		if (suppressTrailingZeroElements) {
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 seconds", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 days", "");
					}
				}
			}
		}
		duration = " " + duration;
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 days", " 1 day");
		return duration.trim();
	}

	public static java.lang.String formatPeriodISO(long startMillis, long endMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, format, true, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format, boolean padWithZeros, java.util.TimeZone timezone) {
		long millis = endMillis - startMillis;
		if (millis < (28 * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY))) {
			return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(millis, format, padWithZeros);
		}
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		java.util.Calendar start = java.util.Calendar.getInstance(timezone);
		start.setTime(new java.util.Date(startMillis));
		java.util.Calendar end = java.util.Calendar.getInstance(timezone);
		end.setTime(new java.util.Date(endMillis));
		int milliseconds = (end.get(java.util.Calendar.MILLISECOND)) - (start.get(java.util.Calendar.MILLISECOND));
		int seconds = (end.get(java.util.Calendar.SECOND)) - (start.get(java.util.Calendar.SECOND));
		int minutes = (end.get(java.util.Calendar.MINUTE)) - (start.get(java.util.Calendar.MINUTE));
		int hours = (end.get(java.util.Calendar.HOUR_OF_DAY)) - (start.get(java.util.Calendar.HOUR_OF_DAY));
		int days = (end.get(java.util.Calendar.DAY_OF_MONTH)) - (start.get(java.util.Calendar.DAY_OF_MONTH));
		int months = (end.get(java.util.Calendar.MONTH)) - (start.get(java.util.Calendar.MONTH));
		int years = (end.get(java.util.Calendar.YEAR)) - (start.get(java.util.Calendar.YEAR));
		while (milliseconds < 0) {
			milliseconds += 1000;
			seconds -= 1;
		} 
		while (seconds < 0) {
			seconds += 60;
			minutes -= 1;
		} 
		while (minutes < 0) {
			minutes += 60;
			hours -= 1;
		} 
		while (hours < 0) {
			hours += 24;
			days -= 1;
		} 
		while (days < 0) {
			days += 31;
			months -= 1;
		} 
		while (months < 0) {
			months += 12;
			years -= 1;
		} 
		milliseconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MILLISECOND, milliseconds);
		seconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.SECOND, seconds);
		minutes -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MINUTE, minutes);
		hours -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.HOUR_OF_DAY, hours);
		days -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.DAY_OF_MONTH, days);
		months -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MONTH, months);
		years -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.YEAR, years);
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.y))) {
			if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M)) {
				months += 12 * years;
				years = 0;
			}else {
				days += 365 * years;
				years = 0;
			}
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M))) {
			days += (end.get(java.util.Calendar.DAY_OF_YEAR)) - (start.get(java.util.Calendar.DAY_OF_YEAR));
			months = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d))) {
			hours += 24 * days;
			days = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H))) {
			minutes += 60 * hours;
			hours = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m))) {
			seconds += 60 * minutes;
			minutes = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s))) {
			milliseconds += 1000 * seconds;
			seconds = 0;
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	static java.lang.String format(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) {
		java.lang.StringBuffer buffer = new java.lang.StringBuffer();
		boolean lastOutputSeconds = false;
		int sz = tokens.length;
		for (int i = 0; i < sz; i++) {
			org.apache.commons.lang.time.DurationFormatUtils.Token token = tokens[i];
			java.lang.Object value = token.getValue();
			int count = token.getCount();
			if (value instanceof java.lang.StringBuffer) {
				buffer.append(value.toString());
			}else {
				if (value == (org.apache.commons.lang.time.DurationFormatUtils.y)) {
					buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(years), count, '0') : java.lang.Integer.toString(years)));
					lastOutputSeconds = false;
				}else
					if (value == (org.apache.commons.lang.time.DurationFormatUtils.M)) {
						buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(months), count, '0') : java.lang.Integer.toString(months)));
						lastOutputSeconds = false;
					}else
						if (value == (org.apache.commons.lang.time.DurationFormatUtils.d)) {
							buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(days), count, '0') : java.lang.Integer.toString(days)));
							lastOutputSeconds = false;
						}else
							if (value == (org.apache.commons.lang.time.DurationFormatUtils.H)) {
								buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(hours), count, '0') : java.lang.Integer.toString(hours)));
								lastOutputSeconds = false;
							}else
								if (value == (org.apache.commons.lang.time.DurationFormatUtils.m)) {
									buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(minutes), count, '0') : java.lang.Integer.toString(minutes)));
									lastOutputSeconds = false;
								}else
									if (value == (org.apache.commons.lang.time.DurationFormatUtils.s)) {
										buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(seconds), count, '0') : java.lang.Integer.toString(seconds)));
										lastOutputSeconds = true;
									}else
										if (value == (org.apache.commons.lang.time.DurationFormatUtils.S)) {
											if (lastOutputSeconds) {
												milliseconds += 1000;
												java.lang.String str = (padWithZeros) ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds);
												buffer.append(str.substring(1));
											}else {
												buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds)));
											}
											lastOutputSeconds = false;
										}
									
								
							
						
					
				
			}
		}
		return buffer.toString();
	}

	static int reduceAndCorrect(java.util.Calendar start, java.util.Calendar end, int field, int difference) {
		end.add(field, ((-1) * difference));
		int endValue = end.get(field);
		int startValue = start.get(field);
		if (endValue < startValue) {
			int newdiff = startValue - endValue;
			end.add(field, newdiff);
			return newdiff;
		}else {
			return 0;
		}
	}

	static final java.lang.Object y = "y";

	static final java.lang.Object M = "M";

	static final java.lang.Object d = "d";

	static final java.lang.Object H = "H";

	static final java.lang.Object m = "m";

	static final java.lang.Object s = "s";

	static final java.lang.Object S = "S";

	static org.apache.commons.lang.time.DurationFormatUtils.Token[] lexx(java.lang.String format) {
		char[] array = format.toCharArray();
		java.util.ArrayList list = new java.util.ArrayList(array.length);
		boolean inLiteral = false;
		java.lang.StringBuffer buffer = null;
		org.apache.commons.lang.time.DurationFormatUtils.Token previous = null;
		int sz = array.length;
		for (int i = 0; i < sz; i++) {
			char ch = array[i];
			if (inLiteral && (ch != '\'')) {
				buffer.append(ch);
				continue;
			}
			java.lang.Object value = null;
			switch (ch) {
				case '\'' :
					if (inLiteral) {
						buffer = null;
						inLiteral = false;
					}else {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
						inLiteral = true;
					}
					break;
				case 'y' :
					value = org.apache.commons.lang.time.DurationFormatUtils.y;
					break;
				case 'M' :
					value = org.apache.commons.lang.time.DurationFormatUtils.M;
					break;
				case 'd' :
					value = org.apache.commons.lang.time.DurationFormatUtils.d;
					break;
				case 'H' :
					value = org.apache.commons.lang.time.DurationFormatUtils.H;
					break;
				case 'm' :
					value = org.apache.commons.lang.time.DurationFormatUtils.m;
					break;
				case 's' :
					value = org.apache.commons.lang.time.DurationFormatUtils.s;
					break;
				case 'S' :
					value = org.apache.commons.lang.time.DurationFormatUtils.S;
					break;
				default :
					if (buffer == null) {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
					}
					buffer.append(ch);
			}
			if (value != null) {
				if ((previous != null) && ((previous.getValue()) == value)) {
					previous.increment();
				}else {
					org.apache.commons.lang.time.DurationFormatUtils.Token token = new org.apache.commons.lang.time.DurationFormatUtils.Token(value);
					list.add(token);
					previous = token;
				}
				buffer = null;
			}
		}
		return ((org.apache.commons.lang.time.DurationFormatUtils.Token[]) (list.toArray(new org.apache.commons.lang.time.DurationFormatUtils.Token[0])));
	}

	static class Token {
		static boolean containsTokenWithValue(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, java.lang.Object value) {
			int sz = tokens.length;
			for (int i = 0; i < sz; i++) {
				if ((tokens[i].getValue()) == value) {
					return true;
				}
			}
			return false;
		}

		private java.lang.Object value;

		private int count;

		Token(java.lang.Object value) {
			this.value = value;
			this.count = 1;
		}

		Token(java.lang.Object value, int count) {
			this.value = value;
			this.count = count;
		}

		void increment() {
			(count)++;
		}

		int getCount() {
			return count;
		}

		java.lang.Object getValue() {
			return value;
		}

		public boolean equals(java.lang.Object obj2) {
			if (obj2 instanceof org.apache.commons.lang.time.DurationFormatUtils.Token) {
				org.apache.commons.lang.time.DurationFormatUtils.Token tok2 = ((org.apache.commons.lang.time.DurationFormatUtils.Token) (obj2));
				if ((this.value.getClass()) != (tok2.value.getClass())) {
					return false;
				}
				if ((this.count) != (tok2.count)) {
					return false;
				}
				if ((this.value) instanceof java.lang.StringBuffer) {
					return this.value.toString().equals(tok2.value.toString());
				}else
					if ((this.value) instanceof java.lang.Number) {
						return this.value.equals(tok2.value);
					}else {
						return (this.value) == (tok2.value);
					}
				
			}else {
				return false;
			}
		}

		public int hashCode() {
			return this.value.hashCode();
		}

		public java.lang.String toString() {
			return org.apache.commons.lang.StringUtils.repeat(this.value.toString(), this.count);
		}
	}
}
2019-04-13 19:19:22,334 ERROR main - Undo Error: modified: 
public class DurationFormatUtils {
	public DurationFormatUtils() {
		super();
	}

	public static final java.lang.String ISO_EXTENDED_FORMAT_PATTERN = "'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'";

	public static java.lang.String formatDurationHMS(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "H:mm:ss.SSS");
	}

	public static java.lang.String formatDurationISO(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, format, true);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format, boolean padWithZeros) {
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		int days = 0;
		int hours = 0;
		int minutes = 0;
		int seconds = 0;
		int milliseconds = 0;
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d)) {
			days = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY)));
			durationMillis = durationMillis - (days * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H)) {
			hours = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR)));
			durationMillis = durationMillis - (hours * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m)) {
			minutes = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE)));
			durationMillis = durationMillis - (minutes * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s)) {
			seconds = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND)));
			durationMillis = durationMillis - (seconds * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.S)) {
			milliseconds = ((int) (durationMillis));
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	public static java.lang.String formatDurationWords(long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements) {
		java.lang.String duration = org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");
		if (suppressLeadingZeroElements) {
			duration = " " + duration;
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 days", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
					duration = tmp;
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 seconds", "");
					}
				}
			}
			if ((duration.length()) != 0) {
				duration = duration.substring(1);
			}
		}
		if (suppressTrailingZeroElements) {
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 seconds", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 days", "");
					}
				}
			}
		}
		duration = " " + duration;
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 days", " 1 day");
		return duration.trim();
	}

	public static java.lang.String formatPeriodISO(long startMillis, long endMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, format, true, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format, boolean padWithZeros, java.util.TimeZone timezone) {
		long millis = endMillis - startMillis;
		if (millis < (28 * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY))) {
			return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(millis, format, padWithZeros);
		}
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		java.util.Calendar start = java.util.Calendar.getInstance(timezone);
		start.setTime(new java.util.Date(startMillis));
		java.util.Calendar end = java.util.Calendar.getInstance(timezone);
		end.setTime(new java.util.Date(endMillis));
		int milliseconds = (end.get(java.util.Calendar.MILLISECOND)) - (start.get(java.util.Calendar.MILLISECOND));
		int seconds = (end.get(java.util.Calendar.SECOND)) - (start.get(java.util.Calendar.SECOND));
		int minutes = (end.get(java.util.Calendar.MINUTE)) - (start.get(java.util.Calendar.MINUTE));
		int hours = (end.get(java.util.Calendar.HOUR_OF_DAY)) - (start.get(java.util.Calendar.HOUR_OF_DAY));
		int days = (end.get(java.util.Calendar.DAY_OF_MONTH)) - (start.get(java.util.Calendar.DAY_OF_MONTH));
		int months = (end.get(java.util.Calendar.MONTH)) - (start.get(java.util.Calendar.MONTH));
		int years = (end.get(java.util.Calendar.YEAR)) - (start.get(java.util.Calendar.YEAR));
		while (milliseconds < 0) {
			milliseconds += 1000;
			seconds -= 1;
		} 
		while (seconds < 0) {
			seconds += 60;
			minutes -= 1;
		} 
		while (minutes < 0) {
			minutes += 60;
			hours -= 1;
		} 
		while (hours < 0) {
			hours += 24;
			days -= 1;
		} 
		while (days < 0) {
			days += 31;
			months -= 1;
		} 
		while (months < 0) {
			months += 12;
			years -= 1;
		} 
		milliseconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MILLISECOND, milliseconds);
		seconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.SECOND, seconds);
		minutes -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MINUTE, minutes);
		hours -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.HOUR_OF_DAY, hours);
		days -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.DAY_OF_MONTH, days);
		months -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MONTH, months);
		years -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.YEAR, years);
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.y)))
			if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M)) {
				months += 12 * years;
				years = 0;
			}else {
				days += 365 * years;
				years = 0;
			}
		
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M))) {
			days += (end.get(java.util.Calendar.DAY_OF_YEAR)) - (start.get(java.util.Calendar.DAY_OF_YEAR));
			months = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d))) {
			hours += 24 * days;
			days = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H))) {
			minutes += 60 * hours;
			hours = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m))) {
			seconds += 60 * minutes;
			minutes = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s))) {
			milliseconds += 1000 * seconds;
			seconds = 0;
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	static java.lang.String format(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) {
		java.lang.StringBuffer buffer = new java.lang.StringBuffer();
		boolean lastOutputSeconds = false;
		int sz = tokens.length;
		for (int i = 0; i < sz; i++) {
			org.apache.commons.lang.time.DurationFormatUtils.Token token = tokens[i];
			java.lang.Object value = token.getValue();
			int count = token.getCount();
			if (value instanceof java.lang.StringBuffer) {
				buffer.append(value.toString());
			}else {
				if (value == (org.apache.commons.lang.time.DurationFormatUtils.y)) {
					buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(years), count, '0') : java.lang.Integer.toString(years)));
					lastOutputSeconds = false;
				}else
					if (value == (org.apache.commons.lang.time.DurationFormatUtils.M)) {
						buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(months), count, '0') : java.lang.Integer.toString(months)));
						lastOutputSeconds = false;
					}else
						if (value == (org.apache.commons.lang.time.DurationFormatUtils.d)) {
							buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(days), count, '0') : java.lang.Integer.toString(days)));
							lastOutputSeconds = false;
						}else
							if (value == (org.apache.commons.lang.time.DurationFormatUtils.H)) {
								buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(hours), count, '0') : java.lang.Integer.toString(hours)));
								lastOutputSeconds = false;
							}else
								if (value == (org.apache.commons.lang.time.DurationFormatUtils.m)) {
									buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(minutes), count, '0') : java.lang.Integer.toString(minutes)));
									lastOutputSeconds = false;
								}else
									if (value == (org.apache.commons.lang.time.DurationFormatUtils.s)) {
										buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(seconds), count, '0') : java.lang.Integer.toString(seconds)));
										lastOutputSeconds = true;
									}else
										if (value == (org.apache.commons.lang.time.DurationFormatUtils.S)) {
											if (lastOutputSeconds) {
												milliseconds += 1000;
												java.lang.String str = (padWithZeros) ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds);
												buffer.append(str.substring(1));
											}else {
												buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds)));
											}
											lastOutputSeconds = false;
										}
									
								
							
						
					
				
			}
		}
		return buffer.toString();
	}

	static int reduceAndCorrect(java.util.Calendar start, java.util.Calendar end, int field, int difference) {
		end.add(field, ((-1) * difference));
		int endValue = end.get(field);
		int startValue = start.get(field);
		if (endValue < startValue) {
			int newdiff = startValue - endValue;
			end.add(field, newdiff);
			return newdiff;
		}else {
			return 0;
		}
	}

	static final java.lang.Object y = "y";

	static final java.lang.Object M = "M";

	static final java.lang.Object d = "d";

	static final java.lang.Object H = "H";

	static final java.lang.Object m = "m";

	static final java.lang.Object s = "s";

	static final java.lang.Object S = "S";

	static org.apache.commons.lang.time.DurationFormatUtils.Token[] lexx(java.lang.String format) {
		char[] array = format.toCharArray();
		java.util.ArrayList list = new java.util.ArrayList(array.length);
		boolean inLiteral = false;
		java.lang.StringBuffer buffer = null;
		org.apache.commons.lang.time.DurationFormatUtils.Token previous = null;
		int sz = array.length;
		for (int i = 0; i < sz; i++) {
			char ch = array[i];
			if (inLiteral && (ch != '\'')) {
				buffer.append(ch);
				continue;
			}
			java.lang.Object value = null;
			switch (ch) {
				case '\'' :
					if (inLiteral) {
						buffer = null;
						inLiteral = false;
					}else {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
						inLiteral = true;
					}
					break;
				case 'y' :
					value = org.apache.commons.lang.time.DurationFormatUtils.y;
					break;
				case 'M' :
					value = org.apache.commons.lang.time.DurationFormatUtils.M;
					break;
				case 'd' :
					value = org.apache.commons.lang.time.DurationFormatUtils.d;
					break;
				case 'H' :
					value = org.apache.commons.lang.time.DurationFormatUtils.H;
					break;
				case 'm' :
					value = org.apache.commons.lang.time.DurationFormatUtils.m;
					break;
				case 's' :
					value = org.apache.commons.lang.time.DurationFormatUtils.s;
					break;
				case 'S' :
					value = org.apache.commons.lang.time.DurationFormatUtils.S;
					break;
				default :
					if (buffer == null) {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
					}
					buffer.append(ch);
			}
			if (value != null) {
				if ((previous != null) && ((previous.getValue()) == value)) {
					previous.increment();
				}else {
					org.apache.commons.lang.time.DurationFormatUtils.Token token = new org.apache.commons.lang.time.DurationFormatUtils.Token(value);
					list.add(token);
					previous = token;
				}
				buffer = null;
			}
		}
		return ((org.apache.commons.lang.time.DurationFormatUtils.Token[]) (list.toArray(new org.apache.commons.lang.time.DurationFormatUtils.Token[0])));
	}

	static class Token {
		static boolean containsTokenWithValue(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, java.lang.Object value) {
			int sz = tokens.length;
			for (int i = 0; i < sz; i++) {
				if ((tokens[i].getValue()) == value) {
					return true;
				}
			}
			return false;
		}

		private java.lang.Object value;

		private int count;

		Token(java.lang.Object value) {
			this.value = value;
			this.count = 1;
		}

		Token(java.lang.Object value, int count) {
			this.value = value;
			this.count = count;
		}

		void increment() {
			(count)++;
		}

		int getCount() {
			return count;
		}

		java.lang.Object getValue() {
			return value;
		}

		public boolean equals(java.lang.Object obj2) {
			if (obj2 instanceof org.apache.commons.lang.time.DurationFormatUtils.Token) {
				org.apache.commons.lang.time.DurationFormatUtils.Token tok2 = ((org.apache.commons.lang.time.DurationFormatUtils.Token) (obj2));
				if ((this.value.getClass()) != (tok2.value.getClass())) {
					return false;
				}
				if ((this.count) != (tok2.count)) {
					return false;
				}
				if ((this.value) instanceof java.lang.StringBuffer) {
					return this.value.toString().equals(tok2.value.toString());
				}else
					if ((this.value) instanceof java.lang.Number) {
						return this.value.equals(tok2.value);
					}else {
						return (this.value) == (tok2.value);
					}
				
			}else {
				return false;
			}
		}

		public int hashCode() {
			return this.value.hashCode();
		}

		public java.lang.String toString() {
			return org.apache.commons.lang.StringUtils.repeat(this.value.toString(), this.count);
		}
	}
}
2019-04-13 19:19:22,839 ERROR main - Error: the model was not the same from the original after this generation
2019-04-13 19:19:22,839 ERROR main - Undo Error: original: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0)) {
						countries.add(locale);
					}
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else {
				countries = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:19:22,840 ERROR main - Undo Error: modified: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0)) {
						countries.add(locale);
					}
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else
				countries = java.util.Collections.EMPTY_LIST;
			
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:20:00,316 ERROR main - Error: the model was not the same from the original after this generation
2019-04-13 19:20:00,317 ERROR main - Undo Error: original: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0)) {
						countries.add(locale);
					}
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else {
				countries = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:20:00,317 ERROR main - Undo Error: modified: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0)) {
						countries.add(locale);
					}
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else
				countries = java.util.Collections.EMPTY_LIST;
			
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:20:49,656 ERROR main - Error: the model was not the same from the original after this generation
2019-04-13 19:20:49,656 ERROR main - Undo Error: original: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0)) {
						countries.add(locale);
					}
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else
				countries = java.util.Collections.EMPTY_LIST;
			
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:20:49,657 ERROR main - Undo Error: modified: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0))
						countries.add(locale);
					
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else
				countries = java.util.Collections.EMPTY_LIST;
			
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:20:56,269 ERROR main - Error: the model was not the same from the original after this generation
2019-04-13 19:20:56,270 ERROR main - Undo Error: original: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0)) {
						countries.add(locale);
					}
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else
				countries = java.util.Collections.EMPTY_LIST;
			
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:20:56,270 ERROR main - Undo Error: modified: 
public class LocaleUtils {
	private static final java.util.List cAvailableLocaleList;

	private static java.util.Set cAvailableLocaleSet;

	private static final java.util.Map cLanguagesByCountry = java.util.Collections.synchronizedMap(new java.util.HashMap());

	private static final java.util.Map cCountriesByLanguage = java.util.Collections.synchronizedMap(new java.util.HashMap());

	static {
		java.util.List list = java.util.Arrays.asList(java.util.Locale.getAvailableLocales());
		cAvailableLocaleList = java.util.Collections.unmodifiableList(list);
	}

	public LocaleUtils() {
		super();
	}

	public static java.util.Locale toLocale(java.lang.String str) {
		if (str == null) {
			return null;
		}
		int len = str.length();
		if (((len != 2) && (len != 5)) && (len < 7)) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		char ch0 = str.charAt(0);
		char ch1 = str.charAt(1);
		if ((((ch0 < 'a') || (ch0 > 'z')) || (ch1 < 'a')) || (ch1 > 'z')) {
			throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
		}
		if (len == 2) {
			return new java.util.Locale(str, "");
		}else {
			if ((str.charAt(2)) != '_') {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			char ch3 = str.charAt(3);
			char ch4 = str.charAt(4);
			if ((((ch3 < 'A') || (ch3 > 'Z')) || (ch4 < 'A')) || (ch4 > 'Z')) {
				throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
			}
			if (len == 5) {
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5));
			}else {
				if ((str.charAt(5)) != '_') {
					throw new java.lang.IllegalArgumentException(("Invalid locale format: " + str));
				}
				return new java.util.Locale(str.substring(0, 2), str.substring(3, 5), str.substring(6));
			}
		}
	}

	public static java.util.List localeLookupList(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.localeLookupList(locale, locale);
	}

	public static java.util.List localeLookupList(java.util.Locale locale, java.util.Locale defaultLocale) {
		java.util.List list = new java.util.ArrayList(4);
		if (locale != null) {
			list.add(locale);
			if ((locale.getVariant().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), locale.getCountry()));
			}
			if ((locale.getCountry().length()) > 0) {
				list.add(new java.util.Locale(locale.getLanguage(), ""));
			}
			if ((list.contains(defaultLocale)) == false) {
				list.add(defaultLocale);
			}
		}
		return java.util.Collections.unmodifiableList(list);
	}

	public static java.util.List availableLocaleList() {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleList;
	}

	public static java.util.Set availableLocaleSet() {
		java.util.Set set = org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet;
		if (set == null) {
			set = new java.util.HashSet(org.apache.commons.lang.LocaleUtils.availableLocaleList());
			set = java.util.Collections.unmodifiableSet(set);
			org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet = set;
		}
		return set;
	}

	public static boolean isAvailableLocale(java.util.Locale locale) {
		return org.apache.commons.lang.LocaleUtils.cAvailableLocaleSet.contains(locale);
	}

	public static java.util.List languagesByCountry(java.lang.String countryCode) {
		java.util.List langs = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.get(countryCode)));
		if (langs == null) {
			if (countryCode != null) {
				langs = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if ((countryCode.equals(locale.getCountry())) && ((locale.getVariant().length()) == 0)) {
						langs.add(locale);
					}
				}
				langs = java.util.Collections.unmodifiableList(langs);
			}else {
				langs = java.util.Collections.EMPTY_LIST;
			}
			org.apache.commons.lang.LocaleUtils.cLanguagesByCountry.put(countryCode, langs);
		}
		return langs;
	}

	public static java.util.List countriesByLanguage(java.lang.String languageCode) {
		java.util.List countries = ((java.util.List) (org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.get(languageCode)));
		if (countries == null) {
			if (languageCode != null) {
				countries = new java.util.ArrayList();
				java.util.List locales = org.apache.commons.lang.LocaleUtils.availableLocaleList();
				for (int i = 0; i < (locales.size()); i++) {
					java.util.Locale locale = ((java.util.Locale) (locales.get(i)));
					if (((languageCode.equals(locale.getLanguage())) && ((locale.getCountry().length()) != 0)) && ((locale.getVariant().length()) == 0))
						countries.add(locale);
					
				}
				countries = java.util.Collections.unmodifiableList(countries);
			}else
				countries = java.util.Collections.EMPTY_LIST;
			
			org.apache.commons.lang.LocaleUtils.cCountriesByLanguage.put(languageCode, countries);
		}
		return countries;
	}
}
2019-04-13 19:20:57,651 ERROR main - Error: the model was not the same from the original after this generation
2019-04-13 19:20:57,651 ERROR main - Undo Error: original: 
public class DurationFormatUtils {
	public DurationFormatUtils() {
		super();
	}

	public static final java.lang.String ISO_EXTENDED_FORMAT_PATTERN = "'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'";

	public static java.lang.String formatDurationHMS(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "H:mm:ss.SSS");
	}

	public static java.lang.String formatDurationISO(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, format, true);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format, boolean padWithZeros) {
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		int days = 0;
		int hours = 0;
		int minutes = 0;
		int seconds = 0;
		int milliseconds = 0;
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d)) {
			days = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY)));
			durationMillis = durationMillis - (days * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H)) {
			hours = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR)));
			durationMillis = durationMillis - (hours * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m)) {
			minutes = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE)));
			durationMillis = durationMillis - (minutes * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s)) {
			seconds = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND)));
			durationMillis = durationMillis - (seconds * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.S)) {
			milliseconds = ((int) (durationMillis));
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	public static java.lang.String formatDurationWords(long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements) {
		java.lang.String duration = org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");
		if (suppressLeadingZeroElements) {
			duration = " " + duration;
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 days", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
					duration = tmp;
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 seconds", "");
					}
				}
			}
			if ((duration.length()) != 0) {
				duration = duration.substring(1);
			}
		}
		if (suppressTrailingZeroElements) {
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 seconds", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 days", "");
					}
				}
			}
		}
		duration = " " + duration;
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 days", " 1 day");
		return duration.trim();
	}

	public static java.lang.String formatPeriodISO(long startMillis, long endMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, format, true, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format, boolean padWithZeros, java.util.TimeZone timezone) {
		long millis = endMillis - startMillis;
		if (millis < (28 * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY))) {
			return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(millis, format, padWithZeros);
		}
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		java.util.Calendar start = java.util.Calendar.getInstance(timezone);
		start.setTime(new java.util.Date(startMillis));
		java.util.Calendar end = java.util.Calendar.getInstance(timezone);
		end.setTime(new java.util.Date(endMillis));
		int milliseconds = (end.get(java.util.Calendar.MILLISECOND)) - (start.get(java.util.Calendar.MILLISECOND));
		int seconds = (end.get(java.util.Calendar.SECOND)) - (start.get(java.util.Calendar.SECOND));
		int minutes = (end.get(java.util.Calendar.MINUTE)) - (start.get(java.util.Calendar.MINUTE));
		int hours = (end.get(java.util.Calendar.HOUR_OF_DAY)) - (start.get(java.util.Calendar.HOUR_OF_DAY));
		int days = (end.get(java.util.Calendar.DAY_OF_MONTH)) - (start.get(java.util.Calendar.DAY_OF_MONTH));
		int months = (end.get(java.util.Calendar.MONTH)) - (start.get(java.util.Calendar.MONTH));
		int years = (end.get(java.util.Calendar.YEAR)) - (start.get(java.util.Calendar.YEAR));
		while (milliseconds < 0) {
			milliseconds += 1000;
			seconds -= 1;
		} 
		while (seconds < 0) {
			seconds += 60;
			minutes -= 1;
		} 
		while (minutes < 0) {
			minutes += 60;
			hours -= 1;
		} 
		while (hours < 0) {
			hours += 24;
			days -= 1;
		} 
		while (days < 0) {
			days += 31;
			months -= 1;
		} 
		while (months < 0) {
			months += 12;
			years -= 1;
		} 
		milliseconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MILLISECOND, milliseconds);
		seconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.SECOND, seconds);
		minutes -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MINUTE, minutes);
		hours -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.HOUR_OF_DAY, hours);
		days -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.DAY_OF_MONTH, days);
		months -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MONTH, months);
		years -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.YEAR, years);
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.y))) {
			if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M)) {
				months += 12 * years;
				years = 0;
			}else {
				days += 365 * years;
				years = 0;
			}
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M))) {
			days += (end.get(java.util.Calendar.DAY_OF_YEAR)) - (start.get(java.util.Calendar.DAY_OF_YEAR));
			months = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d))) {
			hours += 24 * days;
			days = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H))) {
			minutes += 60 * hours;
			hours = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m))) {
			seconds += 60 * minutes;
			minutes = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s))) {
			milliseconds += 1000 * seconds;
			seconds = 0;
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	static java.lang.String format(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) {
		java.lang.StringBuffer buffer = new java.lang.StringBuffer();
		boolean lastOutputSeconds = false;
		int sz = tokens.length;
		for (int i = 0; i < sz; i++) {
			org.apache.commons.lang.time.DurationFormatUtils.Token token = tokens[i];
			java.lang.Object value = token.getValue();
			int count = token.getCount();
			if (value instanceof java.lang.StringBuffer) {
				buffer.append(value.toString());
			}else {
				if (value == (org.apache.commons.lang.time.DurationFormatUtils.y)) {
					buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(years), count, '0') : java.lang.Integer.toString(years)));
					lastOutputSeconds = false;
				}else
					if (value == (org.apache.commons.lang.time.DurationFormatUtils.M)) {
						buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(months), count, '0') : java.lang.Integer.toString(months)));
						lastOutputSeconds = false;
					}else
						if (value == (org.apache.commons.lang.time.DurationFormatUtils.d)) {
							buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(days), count, '0') : java.lang.Integer.toString(days)));
							lastOutputSeconds = false;
						}else
							if (value == (org.apache.commons.lang.time.DurationFormatUtils.H)) {
								buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(hours), count, '0') : java.lang.Integer.toString(hours)));
								lastOutputSeconds = false;
							}else
								if (value == (org.apache.commons.lang.time.DurationFormatUtils.m)) {
									buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(minutes), count, '0') : java.lang.Integer.toString(minutes)));
									lastOutputSeconds = false;
								}else
									if (value == (org.apache.commons.lang.time.DurationFormatUtils.s)) {
										buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(seconds), count, '0') : java.lang.Integer.toString(seconds)));
										lastOutputSeconds = true;
									}else
										if (value == (org.apache.commons.lang.time.DurationFormatUtils.S)) {
											if (lastOutputSeconds) {
												milliseconds += 1000;
												java.lang.String str = (padWithZeros) ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds);
												buffer.append(str.substring(1));
											}else {
												buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds)));
											}
											lastOutputSeconds = false;
										}
									
								
							
						
					
				
			}
		}
		return buffer.toString();
	}

	static int reduceAndCorrect(java.util.Calendar start, java.util.Calendar end, int field, int difference) {
		end.add(field, ((-1) * difference));
		int endValue = end.get(field);
		int startValue = start.get(field);
		if (endValue < startValue) {
			int newdiff = startValue - endValue;
			end.add(field, newdiff);
			return newdiff;
		}else {
			return 0;
		}
	}

	static final java.lang.Object y = "y";

	static final java.lang.Object M = "M";

	static final java.lang.Object d = "d";

	static final java.lang.Object H = "H";

	static final java.lang.Object m = "m";

	static final java.lang.Object s = "s";

	static final java.lang.Object S = "S";

	static org.apache.commons.lang.time.DurationFormatUtils.Token[] lexx(java.lang.String format) {
		char[] array = format.toCharArray();
		java.util.ArrayList list = new java.util.ArrayList(array.length);
		boolean inLiteral = false;
		java.lang.StringBuffer buffer = null;
		org.apache.commons.lang.time.DurationFormatUtils.Token previous = null;
		int sz = array.length;
		for (int i = 0; i < sz; i++) {
			char ch = array[i];
			if (inLiteral && (ch != '\'')) {
				buffer.append(ch);
				continue;
			}
			java.lang.Object value = null;
			switch (ch) {
				case '\'' :
					if (inLiteral) {
						buffer = null;
						inLiteral = false;
					}else {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
						inLiteral = true;
					}
					break;
				case 'y' :
					value = org.apache.commons.lang.time.DurationFormatUtils.y;
					break;
				case 'M' :
					value = org.apache.commons.lang.time.DurationFormatUtils.M;
					break;
				case 'd' :
					value = org.apache.commons.lang.time.DurationFormatUtils.d;
					break;
				case 'H' :
					value = org.apache.commons.lang.time.DurationFormatUtils.H;
					break;
				case 'm' :
					value = org.apache.commons.lang.time.DurationFormatUtils.m;
					break;
				case 's' :
					value = org.apache.commons.lang.time.DurationFormatUtils.s;
					break;
				case 'S' :
					value = org.apache.commons.lang.time.DurationFormatUtils.S;
					break;
				default :
					if (buffer == null) {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
					}
					buffer.append(ch);
			}
			if (value != null) {
				if ((previous != null) && ((previous.getValue()) == value)) {
					previous.increment();
				}else {
					org.apache.commons.lang.time.DurationFormatUtils.Token token = new org.apache.commons.lang.time.DurationFormatUtils.Token(value);
					list.add(token);
					previous = token;
				}
				buffer = null;
			}
		}
		return ((org.apache.commons.lang.time.DurationFormatUtils.Token[]) (list.toArray(new org.apache.commons.lang.time.DurationFormatUtils.Token[0])));
	}

	static class Token {
		static boolean containsTokenWithValue(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, java.lang.Object value) {
			int sz = tokens.length;
			for (int i = 0; i < sz; i++) {
				if ((tokens[i].getValue()) == value) {
					return true;
				}
			}
			return false;
		}

		private java.lang.Object value;

		private int count;

		Token(java.lang.Object value) {
			this.value = value;
			this.count = 1;
		}

		Token(java.lang.Object value, int count) {
			this.value = value;
			this.count = count;
		}

		void increment() {
			(count)++;
		}

		int getCount() {
			return count;
		}

		java.lang.Object getValue() {
			return value;
		}

		public boolean equals(java.lang.Object obj2) {
			if (obj2 instanceof org.apache.commons.lang.time.DurationFormatUtils.Token) {
				org.apache.commons.lang.time.DurationFormatUtils.Token tok2 = ((org.apache.commons.lang.time.DurationFormatUtils.Token) (obj2));
				if ((this.value.getClass()) != (tok2.value.getClass())) {
					return false;
				}
				if ((this.count) != (tok2.count)) {
					return false;
				}
				if ((this.value) instanceof java.lang.StringBuffer) {
					return this.value.toString().equals(tok2.value.toString());
				}else
					if ((this.value) instanceof java.lang.Number) {
						return this.value.equals(tok2.value);
					}else {
						return (this.value) == (tok2.value);
					}
				
			}else {
				return false;
			}
		}

		public int hashCode() {
			return this.value.hashCode();
		}

		public java.lang.String toString() {
			return org.apache.commons.lang.StringUtils.repeat(this.value.toString(), this.count);
		}
	}
}
2019-04-13 19:20:57,695 ERROR main - Undo Error: modified: 
public class DurationFormatUtils {
	public DurationFormatUtils() {
		super();
	}

	public static final java.lang.String ISO_EXTENDED_FORMAT_PATTERN = "'P'yyyy'Y'M'M'd'DT'H'H'm'M's.S'S'";

	public static java.lang.String formatDurationHMS(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "H:mm:ss.SSS");
	}

	public static java.lang.String formatDurationISO(long durationMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, format, true);
	}

	public static java.lang.String formatDuration(long durationMillis, java.lang.String format, boolean padWithZeros) {
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		int days = 0;
		int hours = 0;
		int minutes = 0;
		int seconds = 0;
		int milliseconds = 0;
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d)) {
			days = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY)));
			durationMillis = durationMillis - (days * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H)) {
			hours = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR)));
			durationMillis = durationMillis - (hours * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_HOUR));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m)) {
			minutes = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE)));
			durationMillis = durationMillis - (minutes * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_MINUTE));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s)) {
			seconds = ((int) (durationMillis / (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND)));
			durationMillis = durationMillis - (seconds * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_SECOND));
		}
		if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.S)) {
			milliseconds = ((int) (durationMillis));
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, 0, 0, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	public static java.lang.String formatDurationWords(long durationMillis, boolean suppressLeadingZeroElements, boolean suppressTrailingZeroElements) {
		java.lang.String duration = org.apache.commons.lang.time.DurationFormatUtils.formatDuration(durationMillis, "d' days 'H' hours 'm' minutes 's' seconds'");
		if (suppressLeadingZeroElements) {
			duration = " " + duration;
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 days", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
					duration = tmp;
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 seconds", "");
					}
				}
			}
			if ((duration.length()) != 0) {
				duration = duration.substring(1);
			}
		}
		if (suppressTrailingZeroElements) {
			java.lang.String tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 seconds", "");
			if ((tmp.length()) != (duration.length())) {
				duration = tmp;
				tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 minutes", "");
				if ((tmp.length()) != (duration.length())) {
					duration = tmp;
					tmp = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 0 hours", "");
					if ((tmp.length()) != (duration.length())) {
						duration = org.apache.commons.lang.StringUtils.replaceOnce(tmp, " 0 days", "");
					}
				}
			}
		}
		duration = " " + duration;
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 seconds", " 1 second");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 minutes", " 1 minute");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 hours", " 1 hour");
		duration = org.apache.commons.lang.StringUtils.replaceOnce(duration, " 1 days", " 1 day");
		return duration.trim();
	}

	public static java.lang.String formatPeriodISO(long startMillis, long endMillis) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, org.apache.commons.lang.time.DurationFormatUtils.ISO_EXTENDED_FORMAT_PATTERN, false, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format) {
		return org.apache.commons.lang.time.DurationFormatUtils.formatPeriod(startMillis, endMillis, format, true, java.util.TimeZone.getDefault());
	}

	public static java.lang.String formatPeriod(long startMillis, long endMillis, java.lang.String format, boolean padWithZeros, java.util.TimeZone timezone) {
		long millis = endMillis - startMillis;
		if (millis < (28 * (org.apache.commons.lang.time.DateUtils.MILLIS_PER_DAY))) {
			return org.apache.commons.lang.time.DurationFormatUtils.formatDuration(millis, format, padWithZeros);
		}
		org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens = org.apache.commons.lang.time.DurationFormatUtils.lexx(format);
		java.util.Calendar start = java.util.Calendar.getInstance(timezone);
		start.setTime(new java.util.Date(startMillis));
		java.util.Calendar end = java.util.Calendar.getInstance(timezone);
		end.setTime(new java.util.Date(endMillis));
		int milliseconds = (end.get(java.util.Calendar.MILLISECOND)) - (start.get(java.util.Calendar.MILLISECOND));
		int seconds = (end.get(java.util.Calendar.SECOND)) - (start.get(java.util.Calendar.SECOND));
		int minutes = (end.get(java.util.Calendar.MINUTE)) - (start.get(java.util.Calendar.MINUTE));
		int hours = (end.get(java.util.Calendar.HOUR_OF_DAY)) - (start.get(java.util.Calendar.HOUR_OF_DAY));
		int days = (end.get(java.util.Calendar.DAY_OF_MONTH)) - (start.get(java.util.Calendar.DAY_OF_MONTH));
		int months = (end.get(java.util.Calendar.MONTH)) - (start.get(java.util.Calendar.MONTH));
		int years = (end.get(java.util.Calendar.YEAR)) - (start.get(java.util.Calendar.YEAR));
		while (milliseconds < 0) {
			milliseconds += 1000;
			seconds -= 1;
		} 
		while (seconds < 0) {
			seconds += 60;
			minutes -= 1;
		} 
		while (minutes < 0) {
			minutes += 60;
			hours -= 1;
		} 
		while (hours < 0) {
			hours += 24;
			days -= 1;
		} 
		while (days < 0) {
			days += 31;
			months -= 1;
		} 
		while (months < 0) {
			months += 12;
			years -= 1;
		} 
		milliseconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MILLISECOND, milliseconds);
		seconds -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.SECOND, seconds);
		minutes -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MINUTE, minutes);
		hours -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.HOUR_OF_DAY, hours);
		days -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.DAY_OF_MONTH, days);
		months -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.MONTH, months);
		years -= org.apache.commons.lang.time.DurationFormatUtils.reduceAndCorrect(start, end, java.util.Calendar.YEAR, years);
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.y)))
			if (org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M)) {
				months += 12 * years;
				years = 0;
			}else {
				days += 365 * years;
				years = 0;
			}
		
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.M))) {
			days += (end.get(java.util.Calendar.DAY_OF_YEAR)) - (start.get(java.util.Calendar.DAY_OF_YEAR));
			months = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.d))) {
			hours += 24 * days;
			days = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.H))) {
			minutes += 60 * hours;
			hours = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.m))) {
			seconds += 60 * minutes;
			minutes = 0;
		}
		if (!(org.apache.commons.lang.time.DurationFormatUtils.Token.containsTokenWithValue(tokens, org.apache.commons.lang.time.DurationFormatUtils.s))) {
			milliseconds += 1000 * seconds;
			seconds = 0;
		}
		return org.apache.commons.lang.time.DurationFormatUtils.format(tokens, years, months, days, hours, minutes, seconds, milliseconds, padWithZeros);
	}

	static java.lang.String format(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, int years, int months, int days, int hours, int minutes, int seconds, int milliseconds, boolean padWithZeros) {
		java.lang.StringBuffer buffer = new java.lang.StringBuffer();
		boolean lastOutputSeconds = false;
		int sz = tokens.length;
		for (int i = 0; i < sz; i++) {
			org.apache.commons.lang.time.DurationFormatUtils.Token token = tokens[i];
			java.lang.Object value = token.getValue();
			int count = token.getCount();
			if (value instanceof java.lang.StringBuffer) {
				buffer.append(value.toString());
			}else {
				if (value == (org.apache.commons.lang.time.DurationFormatUtils.y)) {
					buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(years), count, '0') : java.lang.Integer.toString(years)));
					lastOutputSeconds = false;
				}else
					if (value == (org.apache.commons.lang.time.DurationFormatUtils.M)) {
						buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(months), count, '0') : java.lang.Integer.toString(months)));
						lastOutputSeconds = false;
					}else
						if (value == (org.apache.commons.lang.time.DurationFormatUtils.d)) {
							buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(days), count, '0') : java.lang.Integer.toString(days)));
							lastOutputSeconds = false;
						}else
							if (value == (org.apache.commons.lang.time.DurationFormatUtils.H)) {
								buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(hours), count, '0') : java.lang.Integer.toString(hours)));
								lastOutputSeconds = false;
							}else
								if (value == (org.apache.commons.lang.time.DurationFormatUtils.m)) {
									buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(minutes), count, '0') : java.lang.Integer.toString(minutes)));
									lastOutputSeconds = false;
								}else
									if (value == (org.apache.commons.lang.time.DurationFormatUtils.s)) {
										buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(seconds), count, '0') : java.lang.Integer.toString(seconds)));
										lastOutputSeconds = true;
									}else
										if (value == (org.apache.commons.lang.time.DurationFormatUtils.S)) {
											if (lastOutputSeconds) {
												milliseconds += 1000;
												java.lang.String str = (padWithZeros) ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds);
												buffer.append(str.substring(1));
											}else {
												buffer.append((padWithZeros ? org.apache.commons.lang.StringUtils.leftPad(java.lang.Integer.toString(milliseconds), count, '0') : java.lang.Integer.toString(milliseconds)));
											}
											lastOutputSeconds = false;
										}
									
								
							
						
					
				
			}
		}
		return buffer.toString();
	}

	static int reduceAndCorrect(java.util.Calendar start, java.util.Calendar end, int field, int difference) {
		end.add(field, ((-1) * difference));
		int endValue = end.get(field);
		int startValue = start.get(field);
		if (endValue < startValue) {
			int newdiff = startValue - endValue;
			end.add(field, newdiff);
			return newdiff;
		}else {
			return 0;
		}
	}

	static final java.lang.Object y = "y";

	static final java.lang.Object M = "M";

	static final java.lang.Object d = "d";

	static final java.lang.Object H = "H";

	static final java.lang.Object m = "m";

	static final java.lang.Object s = "s";

	static final java.lang.Object S = "S";

	static org.apache.commons.lang.time.DurationFormatUtils.Token[] lexx(java.lang.String format) {
		char[] array = format.toCharArray();
		java.util.ArrayList list = new java.util.ArrayList(array.length);
		boolean inLiteral = false;
		java.lang.StringBuffer buffer = null;
		org.apache.commons.lang.time.DurationFormatUtils.Token previous = null;
		int sz = array.length;
		for (int i = 0; i < sz; i++) {
			char ch = array[i];
			if (inLiteral && (ch != '\'')) {
				buffer.append(ch);
				continue;
			}
			java.lang.Object value = null;
			switch (ch) {
				case '\'' :
					if (inLiteral) {
						buffer = null;
						inLiteral = false;
					}else {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
						inLiteral = true;
					}
					break;
				case 'y' :
					value = org.apache.commons.lang.time.DurationFormatUtils.y;
					break;
				case 'M' :
					value = org.apache.commons.lang.time.DurationFormatUtils.M;
					break;
				case 'd' :
					value = org.apache.commons.lang.time.DurationFormatUtils.d;
					break;
				case 'H' :
					value = org.apache.commons.lang.time.DurationFormatUtils.H;
					break;
				case 'm' :
					value = org.apache.commons.lang.time.DurationFormatUtils.m;
					break;
				case 's' :
					value = org.apache.commons.lang.time.DurationFormatUtils.s;
					break;
				case 'S' :
					value = org.apache.commons.lang.time.DurationFormatUtils.S;
					break;
				default :
					if (buffer == null) {
						buffer = new java.lang.StringBuffer();
						list.add(new org.apache.commons.lang.time.DurationFormatUtils.Token(buffer));
					}
					buffer.append(ch);
			}
			if (value != null) {
				if ((previous != null) && ((previous.getValue()) == value)) {
					previous.increment();
				}else {
					org.apache.commons.lang.time.DurationFormatUtils.Token token = new org.apache.commons.lang.time.DurationFormatUtils.Token(value);
					list.add(token);
					previous = token;
				}
				buffer = null;
			}
		}
		return ((org.apache.commons.lang.time.DurationFormatUtils.Token[]) (list.toArray(new org.apache.commons.lang.time.DurationFormatUtils.Token[0])));
	}

	static class Token {
		static boolean containsTokenWithValue(org.apache.commons.lang.time.DurationFormatUtils.Token[] tokens, java.lang.Object value) {
			int sz = tokens.length;
			for (int i = 0; i < sz; i++) {
				if ((tokens[i].getValue()) == value) {
					return true;
				}
			}
			return false;
		}

		private java.lang.Object value;

		private int count;

		Token(java.lang.Object value) {
			this.value = value;
			this.count = 1;
		}

		Token(java.lang.Object value, int count) {
			this.value = value;
			this.count = count;
		}

		void increment() {
			(count)++;
		}

		int getCount() {
			return count;
		}

		java.lang.Object getValue() {
			return value;
		}

		public boolean equals(java.lang.Object obj2) {
			if (obj2 instanceof org.apache.commons.lang.time.DurationFormatUtils.Token) {
				org.apache.commons.lang.time.DurationFormatUtils.Token tok2 = ((org.apache.commons.lang.time.DurationFormatUtils.Token) (obj2));
				if ((this.value.getClass()) != (tok2.value.getClass())) {
					return false;
				}
				if ((this.count) != (tok2.count)) {
					return false;
				}
				if ((this.value) instanceof java.lang.StringBuffer) {
					return this.value.toString().equals(tok2.value.toString());
				}else
					if ((this.value) instanceof java.lang.Number) {
						return this.value.equals(tok2.value);
					}else {
						return (this.value) == (tok2.value);
					}
				
			}else {
				return false;
			}
		}

		public int hashCode() {
			return this.value.hashCode();
		}

		public java.lang.String toString() {
			return org.apache.commons.lang.StringUtils.repeat(this.value.toString(), this.count);
		}
	}
}
2019-04-13 19:25:49,895 INFO main - Time Repair Loop (s): 389.677
2019-04-13 19:25:49,896 INFO main - 
----SUMMARY_EXECUTION---
2019-04-13 19:25:49,896 INFO main - 
successful_ing_attempts (0): []
2019-04-13 19:25:49,896 INFO main - 
failing_ing_attempts (600): [2, 0, 1, 3, 0, 2, 1, 0, 6, 2, 0, 11, 0, 0, 10, 0, 8, 0, 4, 0, 2, 1, 5, 2, 2, 5, 4, 3, 11, 1, 2, 0, 9, 1, 4, 3, 0, 2, 0, 2, 0, 3, 0, 1, 10, 1, 2, 0, 6, 7, 2, 2, 1, 1, 5, 2, 7, 2, 0, 2, 9, 1, 3, 1, 4, 3, 2, 13, 0, 2, 11, 4, 1, 1, 8, 11, 5, 8, 1, 0, 6, 9, 4, 0, 0, 1, 0, 1, 1, 2, 11, 5, 7, 2, 1, 0, 0, 8, 2, 0, 4, 2, 1, 1, 1, 4, 1, 0, 2, 5, 0, 1, 2, 1, 3, 3, 1, 3, 1, 0, 1, 4, 6, 3, 1, 5, 2, 6, 2, 0, 0, 3, 2, 10, 0, 0, 2, 1, 11, 4, 1, 15, 1, 6, 1, 2, 1, 0, 3, 5, 3, 0, 0, 28, 1, 1, 1, 1, 0, 8, 2, 0, 2, 1, 1, 0, 1, 0, 26, 0, 0, 1, 4, 1, 0, 5, 11, 2, 5, 4, 1, 0, 3, 1, 3, 4, 1, 4, 3, 0, 6, 3, 3, 0, 13, 1, 2, 2, 0, 1, 1, 1, 1, 4, 1, 4, 1, 0, 2, 5, 0, 2, 1, 3, 1, 1, 1, 1, 0, 0, 1, 7, 4, 1, 0, 1, 5, 0, 7, 2, 8, 2, 1, 6, 7, 4, 0, 1, 2, 0, 7, 2, 0, 1, 7, 0, 2, 6, 1, 1, 1, 1, 1, 0, 1, 1, 12, 2, 1, 17, 2, 2, 1, 7, 0, 4, 0, 1, 2, 0, 0, 0, 3, 5, 1, 1, 0, 0, 13, 5, 1, 0, 2, 4, 1, 1, 3, 6, 3, 5, 0, 0, 1, 3, 2, 2, 2, 1, 1, 0, 5, 3, 1, 0, 2, 12, 6, 3, 5, 1, 0, 2, 6, 0, 0, 0, 8, 9, 1, 4, 2, 0, 1, 3, 0, 0, 8, 0, 6, 1, 5, 20, 0, 0, 8, 0, 0, 8, 1, 1, 6, 5, 3, 12, 8, 0, 13, 1, 0, 1, 0, 0, 1, 7, 3, 1, 11, 0, 2, 5, 4, 1, 7, 2, 3, 0, 8, 2, 7, 1, 1, 1, 7, 1, 2, 1, 3, 0, 0, 2, 6, 2, 1, 3, 3, 0, 1, 0, 1, 16, 0, 0, 4, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 10, 3, 9, 1, 1, 0, 1, 0, 3, 0, 7, 2, 2, 5, 0, 1, 1, 11, 1, 0, 0, 0, 1, 0, 0, 5, 1, 0, 2, 10, 0, 1, 4, 10, 1, 1, 1, 1, 0, 2, 0, 1, 2, 2, 1, 0, 1, 0, 1, 2, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 0, 1, 0, 6, 1, 1, 1, 6, 2, 1, 1, 5, 1, 3, 1, 1, 0, 1, 0, 4, 0, 1, 5, 2, 0, 4, 6, 2, 0, 1, 2, 3, 26, 0, 0, 1, 6, 1, 15, 0, 0, 1, 6, 15, 1, 1, 0, 2, 1, 3, 1, 3, 0, 6, 1, 0, 3, 1, 0, 2, 3, 4, 0, 4, 1, 1, 6, 1, 3, 0, 0, 2, 9, 0, 10, 0, 1, 0, 4, 3, 3, 0, 1, 1, 1, 1, 1, 4, 3, 9, 1, 10, 7, 4, 4, 1, 0, 1, 0, 2, 1, 1, 11, 3, 3, 2, 0, 0, 9, 3, 0, 1, 4, 1, 4, 5, 1, 1, 1, 2, 0, 1, 4, 1, 0, 1, 3, 1, 2, 1, 11, 0, 0, 0, 2, 0]
2019-04-13 19:25:49,896 INFO fr.inria.main.evolution.AstorMain - Time Total(s): 422.173
[DONE]
